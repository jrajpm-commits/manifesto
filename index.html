<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Video Generator</title>
    <link rel="icon" href="data:,">
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #3b82f6;
            --accent: #ef4444;
            --success: #10b981;
            --dark: #1e293b;
            --light: #f8fafc;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #334155;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            position: relative;
            min-height: 100vh;
        }
        
        /* Header */
        .app-header {
            background: var(--dark);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .logo i {
            color: #60a5fa;
        }
        
        /* Main Layout */
        .main-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            min-height: calc(100vh - 70px);
        }
        
        /* Sidebar */
        .sidebar {
            background: #0f172a;
            padding: 1.5rem 1rem;
            border-right: 1px solid rgba(255,255,255,0.05);
        }
        
        .sidebar-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            background: transparent;
            border: none;
            color: #cbd5e1;
            text-align: left;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: all 0.2s;
        }
        
        .sidebar-btn:hover, .sidebar-btn.active {
            background: rgba(59, 130, 246, 0.1);
            color: white;
        }
        
        .sidebar-btn i {
            width: 20px;
            text-align: center;
        }
        
        /* Content Area */
        .content-area {
            padding: 1.5rem;
            background: var(--light);
            overflow-y: auto;
        }
        
        .section {
            display: none;
        }
        
        .section.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Video Canvas */
        .video-container {
            background: #1e293b;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            position: relative;
        }
        
        #videoCanvas {
            width: 100%;
            border-radius: 8px;
            background: #0f172a;
            display: block;
            margin: 0 auto;
        }
        
        .canvas-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center;
        }
        
        /* Story Input */
        .story-box {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        #storyText {
            width: 100%;
            min-height: 120px;
            border: none;
            outline: none;
            resize: vertical;
            font-size: 1rem;
            line-height: 1.6;
            background: transparent;
            color: var(--dark);
        }
        
        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -10px 0 30px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #e2e8f0;
        }
        
        .settings-panel.active {
            right: 0;
        }
        
        .settings-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
        }
        
        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .close-settings {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #64748b;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }
        
        .close-settings:hover {
            color: var(--accent);
        }
        
        /* Overlay for mobile */
        .settings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .settings-overlay.active {
            display: block;
        }
        
        /* Settings Sections */
        .settings-group {
            margin-bottom: 2rem;
        }
        
        .settings-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .settings-title i {
            color: var(--primary);
        }
        
        /* Watermark Settings */
        .watermark-controls {
            background: #f8fafc;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        .watermark-preview {
            width: 100%;
            height: 100px;
            background: #e2e8f0;
            border-radius: 6px;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .watermark-image {
            max-width: 80%;
            max-height: 80%;
            opacity: 0.5;
        }
        
        /* Slider Styles */
        .slider-group {
            margin-bottom: 1.5rem;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .slider-value {
            color: var(--primary);
            font-weight: 600;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        /* Format Grid */
        .format-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-top: 1rem;
        }
        
        .format-card {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .format-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }
        
        .format-card.active {
            border-color: var(--primary);
            background: rgba(37, 99, 235, 0.05);
        }
        
        .format-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--dark);
        }
        
        /* JSON Import */
        .json-import {
            background: #f0f9ff;
            border: 2px dashed #bae6fd;
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        
        .json-import i {
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }
        
        /* Batch Controls */
        .batch-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        /* Button Styles */
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.2);
        }
        
        .btn-secondary {
            background: #f1f5f9;
            color: var(--dark);
        }
        
        .btn-secondary:hover {
            background: #e2e8f0;
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        /* Generated Video */
        .generated-video {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            display: none;
        }
        
        /* Progress Bar */
        .progress-container {
            margin: 1.5rem 0;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #64748b;
        }
        
        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            width: 0%;
            transition: width 0.3s;
            border-radius: 4px;
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                display: none;
            }
            
            .sidebar.mobile-visible {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                width: 280px;
                height: 100vh;
                z-index: 1001;
                box-shadow: 10px 0 30px rgba(0,0,0,0.1);
            }
            
            .settings-panel {
                width: 100%;
                right: -100%;
            }
            
            .format-grid {
                grid-template-columns: 1fr;
            }
            
            .batch-controls {
                flex-direction: column;
            }
        }
        
        /* Mobile Menu Toggle */
        .mobile-menu-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
        }
        
        @media (max-width: 768px) {
            .mobile-menu-toggle {
                display: block;
            }
        }
        
        /* Stories List */
        .stories-list {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }
        
        .story-item {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .story-item:hover {
            background: #f8fafc;
        }
        
        .story-item.active {
            background: #f0f9ff;
            border-left: 4px solid var(--primary);
        }
        
        .story-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--dark);
        }
        
        .story-meta {
            font-size: 0.875rem;
            color: #64748b;
            display: flex;
            gap: 1rem;
        }
        
        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .status-draft {
            background: #f1f5f9;
            color: #64748b;
        }
        
        .status-ready {
            background: #d1fae5;
            color: #065f46;
        }
        
        .status-produced {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .status-failed {
            background: #fee2e2;
            color: #991b1b;
        }
        
        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            background: var(--success);
            color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 10000;
            display: none;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <button class="mobile-menu-toggle" onclick="toggleSidebar()">
                <i class="fas fa-bars"></i>
            </button>
            <div class="logo">
                <i class="fas fa-film"></i>
                <span>Video Generator</span>
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
                <div id="memoryStats" style="color: #94a3b8; font-size: 12px; font-weight: 500; margin-right: 10px; display: none;">
                    <i class="fas fa-memory"></i> <span id="memValue">0 MB</span>
                </div>
                <div id="cpuStats" style="color: #94a3b8; font-size: 12px; font-weight: 500; margin-right: 10px; display: none;">
                    <i class="fas fa-microchip"></i> <span id="cpuValue">0% Load</span>
                </div>
                <button class="btn btn-secondary" onclick="toggleSettings()">
                    <i class="fas fa-sliders-h"></i>
                </button>
                <button class="btn btn-primary" onclick="generateVideo()">
                    <i class="fas fa-bolt"></i> Generate
                </button>
            </div>
        </header>
        
        <div class="main-content">
            <!-- Sidebar -->
            <nav class="sidebar" id="sidebar">
                <button class="sidebar-btn active" onclick="showSection('creator')">
                    <i class="fas fa-video"></i> Video Creator
                </button>
                <button class="sidebar-btn" onclick="showSection('stories')">
                    <i class="fas fa-list"></i> Stories Library
                </button>
                <button class="sidebar-btn" onclick="showSection('batch')">
                    <i class="fas fa-layer-group"></i> Batch Generate
                </button>
                <button class="sidebar-btn" onclick="showSection('import')">
                    <i class="fas fa-file-import"></i> Import JSON
                </button>
                <button class="sidebar-btn" onclick="showSection('export')">
                    <i class="fas fa-file-export"></i> Export Videos
                </button>
            </nav>
            
            <!-- Content Area -->
            <main class="content-area">
                <!-- Video Creator Section -->
                <div class="section active" id="creator-section">
                    <div class="video-container">
                        <canvas id="videoCanvas" width="1920" height="1080"></canvas>
                        <div class="canvas-controls">
                            <button class="btn btn-secondary" onclick="playPreview()">
                                <i class="fas fa-play"></i> Preview
                            </button>
                            <button class="btn btn-secondary" onclick="stopPreview()">
                                <i class="fas fa-stop"></i> Stop
                            </button>
                        </div>
                    </div>
                    
                    <div class="story-box">
                        <textarea id="storyText" placeholder="Enter your story here...">A cleaner, more beautiful, and efficiently managed Mumbai. A weary citizen becomes the unlikely leader of a city-wide 'Clean & Green' movement, inspiring millions.</textarea>
                    </div>
                    
                    <div class="batch-controls">
                        <button class="btn btn-primary" onclick="generateVideo()">
                            <i class="fas fa-film"></i> Generate Single Video
                        </button>
                        <button class="btn btn-success" onclick="showSection('batch')">
                            <i class="fas fa-layer-group"></i> Batch Generate
                        </button>
                    </div>
                </div>
                
                <!-- Stories Library Section -->
                <div class="section" id="stories-section">
                    <h2 style="margin-bottom: 1.5rem;">Stories Library</h2>
                    <div class="stories-list" id="storiesList">
                        <!-- Stories will be loaded here -->
                    </div>
                </div>
                
                <!-- Batch Generate Section -->
                <div class="section" id="batch-section">
                    <h2 style="margin-bottom: 1.5rem;">Batch Video Generation</h2>
                    
                    <div id="batchActions" style="display: none; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
                        <div id="batchLibraryControls" style="display: flex; gap: 10px;">
                            <!-- Library buttons will be injected here -->
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="resetStories()">
                            <i class="fas fa-trash-alt"></i> Clear / Reset
                        </button>
                    </div>

                    <div class="json-import">
                        <i class="fas fa-database"></i>
                        <h3>Import Stories from JSON</h3>
                        <p>Upload your JSON file with multiple stories</p>
                        <input type="file" id="batchJsonUpload" accept=".json" style="display: none;">
                        <button class="btn btn-primary" onclick="document.getElementById('batchJsonUpload').click()">
                            <i class="fas fa-upload"></i> Upload JSON
                        </button>
                    </div>
                    
                    <div class="batch-controls">
                        <button class="btn btn-secondary" onclick="selectAllStories()">
                            <i class="fas fa-check-square"></i> Select All
                        </button>
                        <button class="btn btn-secondary" onclick="deselectAllStories()">
                            <i class="fas fa-square"></i> Deselect All
                        </button>
                        <select id="statusFilter" onchange="filterBatchStories(this.value)" style="padding: 0.75rem; border-radius: 8px; border: 1px solid #e2e8f0; background: white; color: #334155; font-weight: 600; cursor: pointer;">
                            <option value="all">All Statuses</option>
                            <option value="ready">Ready</option>
                            <option value="produced">Produced</option>
                            <option value="failed">Failed</option>
                        </select>
                    </div>
                    
                    <div class="stories-list" id="batchStoriesList">
                        <!-- Batch stories will be loaded here -->
                    </div>
                    
                    <div class="progress-container" style="display: none;" id="batchProgress">
                        <div class="progress-header">
                            <span>Batch Processing</span>
                            <span id="batchPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="batchProgressFill" style="width: 0%;"></div>
                        </div>
                        <div style="margin-top: 5px; font-size: 12px; color: #64748b; text-align: right;">
                            <span id="batchETR"></span>
                        </div>
                    </div>
                    
                    <button class="btn btn-success" style="width: 100%; margin-top: 1.5rem;" onclick="startBatchGeneration()">
                        <i class="fas fa-play-circle"></i> Start Batch Generation
                    </button>
                </div>
                
                <!-- Import Section -->
                <div class="section" id="import-section">
                    <h2 style="margin-bottom: 1.5rem;">Import JSON Data</h2>
                    
                    <div class="json-import">
                        <i class="fas fa-file-code"></i>
                        <h3>Import Your Stories</h3>
                        <p>Upload a JSON file containing your stories data</p>
                        <input type="file" id="jsonFileInput" accept=".json" multiple style="display: none;">
                        <div style="margin-bottom: 1rem;">
                            <label style="display: inline-flex; align-items: center; gap: 0.5rem; cursor: pointer; user-select: none; font-size: 0.9rem; color: #475569;">
                                <input type="checkbox" id="appendStories" style="width: 16px; height: 16px; accent-color: var(--primary);">
                                <span>Append to existing stories (don't overwrite)</span>
                            </label>
                        </div>
                        <button class="btn btn-primary" onclick="document.getElementById('jsonFileInput').click()">
                            <i class="fas fa-upload"></i> Choose JSON File
                        </button>
                        <div style="margin-top: 1rem; display: flex; gap: 10px; justify-content: center;">
                            <button class="btn btn-secondary" onclick="loadSampleJSON()">
                                <i class="fas fa-download"></i> Load Sample JSON
                            </button>
                            <button class="btn btn-info" onclick="document.getElementById('folderInput').click()">
                                <i class="fas fa-folder-open"></i> Scan Folder
                            </button>
                            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
                        </div>
                    </div>
                    
                    <div id="quickLoadButtons" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; margin-bottom: 2rem;">
                        <!-- Library buttons will be populated here -->
                    </div>
                    
                    <div id="importedStories" style="display: none;">
                        <h3>Imported Stories (<span id="storyCount">0</span>)</h3>
                        <div class="stories-list" id="importedStoriesList">
                            <!-- Imported stories will appear here -->
                        </div>
                    </div>
                </div>
                
                <!-- Generated Video Section -->
                <div class="generated-video" id="generatedVideoSection">
                    <h3>Generated Video</h3>
                    <video id="videoPlayer" controls style="width: 100%; border-radius: 8px; margin: 1rem 0;"></video>
                    <div class="batch-controls">
                        <button class="btn btn-primary" onclick="downloadVideo()">
                            <i class="fas fa-download"></i> Download Video
                        </button>
                        <button class="btn btn-secondary" onclick="clearVideo()">
                            <i class="fas fa-times"></i> Clear
                        </button>
                    </div>
                </div>
            </main>
        </div>
        
        <!-- Settings Panel -->
        <div class="settings-overlay" id="settingsOverlay" onclick="toggleSettings()"></div>
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <h3 style="font-weight: 600;">Video Settings</h3>
                <button class="close-settings" onclick="toggleSettings()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="settings-content">
                <!-- Video Format -->
                <div class="settings-group">
                    <h4 class="settings-title">
                        <i class="fas fa-expand-alt"></i> Video Format
                    </h4>
                    <div class="format-grid" id="formatGrid">
                        <!-- Formats will be populated by JavaScript -->
                    </div>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem; cursor: pointer;">
                        <input type="checkbox" id="showSafeZones" onchange="drawPreview(); saveSettings()" style="width: 18px; height: 18px;">
                        <span>Show Social Media Safe Zones</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="enableKenBurns" checked onchange="drawPreview(); saveSettings()" style="width: 18px; height: 18px;">
                        <span>Enable Ken Burns Effect (Zoom)</span>
                    </label>
                </div>
                
                <!-- Watermark Settings -->
                <div class="settings-group">
                    <h4 class="settings-title">
                        <i class="fas fa-water"></i> Watermark Settings
                    </h4>
                    <div class="watermark-controls">
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Watermark Opacity</span>
                                <span class="slider-value" id="opacityValue">39%</span>
                            </div>
                            <input type="range" class="slider" id="watermarkOpacity" min="0" max="100" value="39" 
                                   oninput="updateWatermarkOpacity(this.value)">
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Watermark Size</span>
                                <span class="slider-value" id="sizeValue">23%</span>
                            </div>
                            <input type="range" class="slider" id="watermarkSize" min="5" max="50" value="23" 
                                   oninput="updateWatermarkSize(this.value)">
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <div class="slider-label">
                                <span>Credit Text</span>
                            </div>
                            <input type="text" id="creditText" value="Its Mots | AIPC Thane" 
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px; font-size: 0.9rem;"
                                   oninput="drawPreview(); saveSettings()">
                        </div>
                        
                        <button class="btn btn-secondary" style="width: 100%; margin-top: 1rem;" onclick="uploadWatermark()">
                            <i class="fas fa-upload"></i> Upload Watermark Image
                        </button>
                        <div style="margin-top: 0.5rem;">
                            <button class="btn btn-info" style="width: 100%;" onclick="document.getElementById('watermarkFolderUpload').click()">
                                <i class="fas fa-images"></i> Scan Watermark Folder (Round Robin)
                            </button>
                            <input type="file" id="watermarkFolderUpload" webkitdirectory multiple style="display: none;" onchange="handleWatermarkFolderUpload(event)">
                        </div>
                        <input type="file" id="watermarkUpload" accept="image/*" style="display: none;" 
                               onchange="handleWatermarkUpload(this.files[0])">
                        
                        <div class="watermark-preview" id="watermarkPreview">
                            <!-- Watermark preview will appear here -->
                        </div>
                    </div>
                </div>
                
                <!-- Text Settings -->
                <div class="settings-group">
                    <h4 class="settings-title">
                        <i class="fas fa-font"></i> Text Settings
                    </h4>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Text Size</span>
                            <span class="slider-value" id="textSizeValue">48px</span>
                        </div>
                        <input type="range" class="slider" id="textSize" min="24" max="96" value="48" 
                               oninput="updateTextSize(this.value)">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Text Animation Speed</span>
                            <span class="slider-value" id="animationSpeedValue">Normal</span>
                        </div>
                        <input type="range" class="slider" id="animationSpeed" min="1" max="100" value="50" 
                               oninput="updateAnimationSpeed(this.value)">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Background Dimming</span>
                            <span class="slider-value" id="bgDimValue">60%</span>
                        </div>
                        <input type="range" class="slider" id="bgDim" min="0" max="95" value="60" 
                               oninput="updateBgDim(this.value)">
                    </div>
                </div>
                
                <!-- Intro/Outro Settings -->
                <div class="settings-group">
                    <h4 class="settings-title">
                        <i class="fas fa-video"></i> Intro & Outro
                    </h4>
                    
                    <div style="margin-bottom: 1rem;">
                        <div class="slider-label">
                            <span>Intro Video</span>
                            <span class="slider-value" id="introStatus">None</span>
                        </div>
                        <button class="btn btn-secondary" style="width: 100%;" onclick="uploadIntro()">
                            <i class="fas fa-upload"></i> Upload Intro Clip
                        </button>
                        <input type="file" id="introUpload" accept="video/*" style="display: none;" 
                               onchange="handleIntroUpload(this.files[0])">
                    </div>
                    
                    <div>
                        <div class="slider-label">
                            <span>Outro Video</span>
                            <span class="slider-value" id="outroStatus">None</span>
                        </div>
                        <button class="btn btn-secondary" style="width: 100%;" onclick="uploadOutro()">
                            <i class="fas fa-upload"></i> Upload Outro Clip
                        </button>
                        <input type="file" id="outroUpload" accept="video/*" style="display: none;" 
                               onchange="handleOutroUpload(this.files[0])">
                    </div>
                </div>
                
                <!-- Audio Settings -->
                <div class="settings-group">
                    <h4 class="settings-title">
                        <i class="fas fa-music"></i> Audio Settings
                    </h4>
                    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 1rem;" onclick="uploadAudio()">
                        <i class="fas fa-upload"></i> Upload Background Music
                    </button>
                    <input type="file" id="audioUpload" accept="audio/*" style="display: none;" 
                           onchange="handleAudioUpload(this.files[0])">
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Audio Volume</span>
                            <span class="slider-value" id="volumeValue">80%</span>
                        </div>
                        <input type="range" class="slider" id="audioVolume" min="0" max="100" value="80" 
                               oninput="updateAudioVolume(this.value)">
                    </div>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem; cursor: pointer;">
                        <input type="checkbox" id="muteDuringGeneration" checked style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Mute audio playback during generation</span>
                    </label>
                </div>
                
                <!-- Export Settings -->
                <div class="settings-group">
                    <h4 class="settings-title">
                        <i class="fas fa-cog"></i> Export Settings
                    </h4>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; cursor: pointer;">
                        <input type="checkbox" id="autoDownload" checked style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Auto-download videos</span>
                    </label>
                    
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; cursor: pointer;">
                        <input type="checkbox" id="addWatermark" checked style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Add watermark to videos</span>
                    </label>
                    
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="includeAudio" checked style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Include audio in videos</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="generateMetadata" style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Generate Metadata JSON</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="performanceMode" style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Performance Mode (Save CPU)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="autoPauseMemory" checked style="width: 18px; height: 18px;" onchange="saveSettings()">
                        <span>Auto-Pause on High Memory (>90%)</span>
                    </label>
                </div>

                <div style="margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #e2e8f0;">
                    <button class="btn btn-secondary" style="width: 100%; color: #ef4444;" onclick="resetSettings()">
                        <i class="fas fa-trash-restore"></i> Reset All Settings
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Notification -->
        <div class="notification" id="notification"></div>
    </div>

    <!-- Font Awesome -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>

    <script>
        // ==================== CONFIGURATION ====================
        const videoFormats = [
            { id: 'youtube', name: 'YouTube', width: 1920, height: 1080, icon: 'fab fa-youtube' },
            { id: 'instagram', name: 'Instagram', width: 1080, height: 1080, icon: 'fab fa-instagram' },
            { id: 'facebook', name: 'Facebook', width: 1200, height: 630, icon: 'fab fa-facebook' },
            { id: 'linkedin', name: 'LinkedIn', width: 1200, height: 627, icon: 'fab fa-linkedin' },
            { id: 'twitter', name: 'Twitter', width: 1200, height: 675, icon: 'fab fa-twitter' },
            { id: 'tiktok', name: 'TikTok', width: 1080, height: 1920, icon: 'fab fa-tiktok' },
            { id: 'shorts', name: 'Shorts', width: 1080, height: 1920, icon: 'fas fa-mobile-alt' }
        ];

        // Sample JSON data (would be imported by user)
        const sampleJSON = {
            "stories": [
                {
                    "id": 1,
                    "slideNumber": 1,
                    "slideTitleEN": "MISSION 2026",
                    "lineItem": "Vision Statement",
                    "story": "A weary citizen, disillusioned by years of neglect, becomes the unlikely leader of a city-wide 'Clean & Green' movement, inspiring millions.",
                    "status": "ready"
                },
                {
                    "id": 2,
                    "slideNumber": 1,
                    "slideTitleEN": "MISSION 2026",
                    "lineItem": "Slogan",
                    "story": "A rival politician scoffs at the slogan as empty words, but is forced into a humbling public service project that makes him believe in it.",
                    "status": "ready"
                },
                {
                    "id": 3,
                    "slideNumber": 3,
                    "slideTitleEN": "Water Supply",
                    "lineItem": "Rainwater Harvesting",
                    "story": "A drought hits. The official who fast-tracked rainwater harvesting becomes a hero in one neighborhood.",
                    "status": "ready"
                }
            ]
        };

        // ==================== STATE MANAGEMENT ====================
        var currentFormat = 'youtube';
        var currentStory = '';
        var backgroundImage = null;
        var watermarkImage = null;
        var audioFile = null;
        var isPreviewPlaying = false;
        var previewAnimationId = null;
        var stories = [];
        var batchStories = [];

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        const videoPlayer = document.getElementById('videoPlayer');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsOverlay = document.getElementById('settingsOverlay');

        // ==================== INITIALIZATION ====================
        function init() {
            setupFormats();
            updateCanvasSize();
            drawPreview();
            setupEventListeners();
            
            // Set initial story
            currentStory = document.getElementById('storyText').value;
            
            // Load sample stories
            stories = sampleJSON.stories;
            renderStoriesList();
        }

        // ==================== SETUP FUNCTIONS ====================
        function setupFormats() {
            const formatGrid = document.getElementById('formatGrid');
            formatGrid.innerHTML = '';
            
            videoFormats.forEach(format => {
                const card = document.createElement('div');
                card.className = `format-card ${format.id === currentFormat ? 'active' : ''}`;
                card.onclick = () => selectFormat(format.id);
                
                card.innerHTML = `
                    <div class="format-icon">
                        <i class="${format.icon}"></i>
                    </div>
                    <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.25rem;">
                        ${format.name}
                    </div>
                    <div style="font-size: 0.75rem; color: #64748b;">
                        ${format.width}×${format.height}
                    </div>
                `;
                
                formatGrid.appendChild(card);
            });
        }

        // ==================== CANVAS FUNCTIONS ====================
        function updateCanvasSize() {
            const format = videoFormats.find(f => f.id === currentFormat);
            if (!format) return;
            
            const containerWidth = canvas.parentElement.clientWidth - 48;
            const scale = containerWidth / format.width;
            
            canvas.width = format.width;
            canvas.height = format.height;
            canvas.style.width = `${format.width * scale}px`;
            canvas.style.height = `${format.height * scale}px`;
        }

        function drawPreview(time = 0) {
            const format = videoFormats.find(f => f.id === currentFormat);
            if (!format) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            // Draw story text
            drawStoryText(time);
            
            // Draw watermark if enabled
            if (document.getElementById('addWatermark').checked && watermarkImage) {
                drawWatermark();
            }
        }

        function drawBackground() {
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Default gradient background
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#2563eb');
                gradient.addColorStop(1, '#7c3aed');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawStoryText(time) {
            if (!currentStory) return;
            
            const fontSize = parseInt(document.getElementById('textSize').value);
            const animationSpeed = parseInt(document.getElementById('animationSpeed').value) / 50;
            const duration = 5 * animationSpeed;
            const progress = Math.min(time / duration, 1);
            const baseFontSize = parseInt(document.getElementById('textSize').value);
            
            // Draw semi-transparent overlay for readability
            if (backgroundImage) {
                const bgDim = document.getElementById('bgDim') ? parseInt(document.getElementById('bgDim').value) / 100 : 0.75;
                ctx.fillStyle = `rgba(0, 0, 0, ${bgDim})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Use new HTML text renderer with auto-fit
            drawHtmlText(ctx, currentStory, canvas.width, canvas.height, baseFontSize, progress);
            
            // Draw Campaign Footer (Punchline)
            const footerHeight = canvas.height * 0.12;
            const footerY = canvas.height - footerHeight;
            
            const gradient = ctx.createLinearGradient(0, footerY, canvas.width, footerY + footerHeight);
            gradient.addColorStop(0, '#ea580c'); // Campaign Orange
            gradient.addColorStop(1, '#c2410c');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, footerY, canvas.width, footerHeight);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${canvas.height * 0.04}px Arial`;
            ctx.fillText("VOTE FOR CHANGE  •  ELECT US FOR MISSION 2026", canvas.width / 2, footerY + footerHeight / 2);
            
            // Reset
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.globalAlpha = 1;
        }

        function drawWatermark() {
            if (!watermarkImage) return;
            
            const opacity = parseInt(document.getElementById('watermarkOpacity').value) / 100;
            const size = parseInt(document.getElementById('watermarkSize').value) / 100;
            
            const width = canvas.width * size;
            const height = (watermarkImage.height / watermarkImage.width) * width;
            
            const x = canvas.width - width - 20;
            const y = canvas.height - height - 20;
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.drawImage(watermarkImage, x, y, width, height);
            ctx.restore();
        }

        // ==================== PREVIEW FUNCTIONS ====================
        function playPreview() {
            if (isPreviewPlaying) return;
            
            isPreviewPlaying = true;
            const startTime = Date.now();
            
            function animate() {
                if (!isPreviewPlaying) return;
                
                const currentTime = (Date.now() - startTime) / 1000;
                drawPreview(currentTime);
                previewAnimationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function stopPreview() {
            isPreviewPlaying = false;
            if (previewAnimationId) {
                cancelAnimationFrame(previewAnimationId);
            }
            drawPreview(0);
        }

        // ==================== SETTINGS FUNCTIONS ====================
        function toggleSettings() {
            settingsPanel.classList.toggle('active');
            settingsOverlay.classList.toggle('active');
        }

        function selectFormat(formatId) {
            currentFormat = formatId;
            setupFormats();
            updateCanvasSize();
            drawPreview();
        }

        function updateWatermarkOpacity(value) {
            document.getElementById('opacityValue').textContent = `${value}%`;
            drawPreview();
    saveSettings();
        }

        function updateWatermarkSize(value) {
            document.getElementById('sizeValue').textContent = `${value}%`;
            drawPreview();
    saveSettings();
        }

        function updateTextSize(value) {
            document.getElementById('textSizeValue').textContent = `${value}px`;
            drawPreview();
    saveSettings();
        }

        function updateAnimationSpeed(value) {
            const speeds = ['Slow', 'Normal', 'Fast'];
            const speedText = value < 33 ? speeds[0] : value < 66 ? speeds[1] : speeds[2];
            document.getElementById('animationSpeedValue').textContent = speedText;
    saveSettings();
        }

        function updateBgDim(value) {
            document.getElementById('bgDimValue').textContent = `${value}%`;
            drawPreview();
    saveSettings();
        }

        function updateAudioVolume(value) {
            document.getElementById('volumeValue').textContent = `${value}%`;
            if (audioFile) {
                audioFile.volume = value / 100;
            }
    saveSettings();
        }

        // ==================== MEDIA UPLOAD FUNCTIONS ====================
        function uploadWatermark() {
            document.getElementById('watermarkUpload').click();
        }

        function handleWatermarkUpload(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                watermarkImage = new Image();
                watermarkImage.src = e.target.result;
                watermarkImage.onload = function() {
                    const preview = document.getElementById('watermarkPreview');
                    preview.innerHTML = `<img src="${e.target.result}" class="watermark-image" alt="Watermark">`;
                    drawPreview();
                    showNotification('Watermark uploaded successfully!');
                };
            };
            reader.readAsDataURL(file);
        }

        function uploadAudio() {
            document.getElementById('audioUpload').click();
        }

        function handleAudioUpload(file) {
            if (!file) return;
            
            const url = URL.createObjectURL(file);
            audioFile = new Audio(url);
            audioFile.volume = document.getElementById('audioVolume').value / 100;
            
            showNotification('Audio uploaded successfully!');
        }

        // ==================== STORY MANAGEMENT ====================
        function renderStoriesList() {
            const storiesList = document.getElementById('storiesList');
            const batchStoriesList = document.getElementById('batchStoriesList');
            
            storiesList.innerHTML = '';
            batchStoriesList.innerHTML = '';
            
            stories.forEach(story => {
                // Story Library Item
                const storyItem = document.createElement('div');
                storyItem.className = 'story-item';
                storyItem.onclick = () => loadStory(story);
                
                storyItem.innerHTML = `
                    <div class="story-title">${story.slideTitleEN} - ${story.lineItem}</div>
                    <div class="story-meta">
                        <span>Slide ${story.slideNumber}</span>
                        <span class="status-badge status-${story.status}">${story.status}</span>
                    </div>
                `;
                
                storiesList.appendChild(storyItem);
                
                // Batch List Item (with checkbox)
                const batchItem = document.createElement('div');
                batchItem.className = 'story-item';
                
                batchItem.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 1rem;">
                        <input type="checkbox" class="story-checkbox" value="${story.id}" 
                               style="margin-top: 0.25rem;" ${story.status === 'ready' ? 'checked' : ''}>
                        <div style="flex: 1;">
                            <div class="story-title">${story.slideTitleEN} - ${story.lineItem}</div>
                            <div class="story-meta">
                                <span>Slide ${story.slideNumber}</span>
                                <span class="status-badge status-${story.status}">${story.status}</span>
                            </div>
                        </div>
                    </div>
                `;
                
                batchStoriesList.appendChild(batchItem);
            });
        }

        function loadStory(story) {
            currentStory = story.story;
            document.getElementById('storyText').value = story.story;
            drawPreview();
            showSection('creator');
            showNotification(`Loaded: ${story.lineItem}`);
        }

        // ==================== JSON IMPORT ====================
        document.getElementById('jsonFileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const jsonData = JSON.parse(event.target.result);
                    if (jsonData.stories && Array.isArray(jsonData.stories)) {
                        stories = jsonData.stories;
                        renderStoriesList();
                        
                        document.getElementById('importedStories').style.display = 'block';
                        showNotification(`Successfully imported ${stories.length} stories!`);
                    } else {
                        showNotification('Invalid JSON format. Expected array of stories.', 'error');
                    }
                } catch (error) {
                    showNotification('Error parsing JSON file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        });

        // ==================== BATCH GENERATION ====================
        function selectAllStories() {
            document.querySelectorAll('.story-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
            const master = document.getElementById('selectAllCheckbox');
            if(master) master.checked = true;
        }

        function deselectAllStories() {
            document.querySelectorAll('.story-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            const master = document.getElementById('selectAllCheckbox');
            if(master) master.checked = false;
        }

        async function startBatchGeneration() {
            const selectedStories = Array.from(document.querySelectorAll('.story-checkbox:checked'))
                .map(cb => parseInt(cb.value));
            
            if (selectedStories.length === 0) {
                showNotification('Please select at least one story for batch generation.', 'error');
                return;
            }
            
            const batchProgress = document.getElementById('batchProgress');
            const batchProgressFill = document.getElementById('batchProgressFill');
            const batchPercent = document.getElementById('batchPercent');
            
            batchProgress.style.display = 'block';
            batchProgressFill.style.width = '0%';
            batchPercent.textContent = '0%';
            
            const total = selectedStories.length;
            let completed = 0;
            
            for (const storyId of selectedStories) {
                const story = stories.find(s => s.id === storyId);
                if (!story) continue;
                
                // Generate video for this story
                currentStory = story.story;
                await generateSingleVideo(story);
                
                // Update progress
                completed++;
                const progress = Math.round((completed / total) * 100);
                batchProgressFill.style.width = `${progress}%`;
                batchPercent.textContent = `${progress}%`;
                
                // Small delay between videos
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            showNotification(`Batch complete! Generated ${completed} videos.`);
        }

        // ==================== VIDEO GENERATION ====================
        async function generateVideo() {
            const story = {
                id: 0,
                slideTitleEN: "Custom Story",
                lineItem: "Current Story",
                story: currentStory
            };
            
            await generateSingleVideo(story);
        }

        async function generateSingleVideo(story) {
            const format = videoFormats.find(f => f.id === currentFormat);
            if (!format) return;
            
            try {
                // Create offscreen canvas
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = format.width;
                offscreenCanvas.height = format.height;
                const offscreenCtx = offscreenCanvas.getContext('2d');
                
                // Setup MediaRecorder
                const stream = offscreenCanvas.captureStream(30);
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 2500000
                });
                
                const chunks = [];
                
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    // Show video player
                    videoPlayer.src = url;
                    document.getElementById('generatedVideoSection').style.display = 'block';
                    
                    // Auto-download if enabled
                    if (document.getElementById('autoDownload').checked) {
                        downloadGeneratedVideo(url, story);
                    }
                    
                    showNotification(`Video generated: ${story.lineItem}`);
                };
                
                // Start recording
                mediaRecorder.start();
                
                const duration = 15; // seconds
                const fps = 30;
                const totalFrames = duration * fps;
                
                // Generate frames
                for (let frame = 0; frame < totalFrames; frame++) {
                    const time = frame / fps;
                    
                    // Draw frame
                    offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                    
                    // Draw background
                    if (backgroundImage) {
                        offscreenCtx.drawImage(backgroundImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
                    } else {
                        const gradient = offscreenCtx.createLinearGradient(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                        gradient.addColorStop(0, '#2563eb');
                        gradient.addColorStop(1, '#7c3aed');
                        offscreenCtx.fillStyle = gradient;
                        offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                    }
                    
                    // Draw story text
                    drawStoryFrame(offscreenCtx, story.story, time, offscreenCanvas.width, offscreenCanvas.height);
                    
                    // Draw watermark if enabled
                    if (document.getElementById('addWatermark').checked && watermarkImage) {
                        drawWatermarkFrame(offscreenCtx, offscreenCanvas.width, offscreenCanvas.height);
                    }
                    
                    // Wait for next frame
                    await new Promise(resolve => setTimeout(resolve, 1000 / fps));
                }
                
                // Stop recording
                mediaRecorder.stop();
                
            } catch (error) {
                console.error('Video generation error:', error);
                showNotification('Error generating video: ' + error.message, 'error');
            }
        }

        function drawStoryFrame(ctx, storyText, time, width, height) {
            const fontSize = parseInt(document.getElementById('textSize').value);
            const duration = 15;
            const progress = Math.min(time / duration, 1);
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Text shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // Split text
            const words = storyText.split(' ');
            const lines = [];
            let currentLine = words[0];
            const maxWidth = width * 0.8;
            
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width < maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = words[i];
                }
            }
            lines.push(currentLine);
            
            // Fade animation
            ctx.globalAlpha = progress;
            
            // Draw lines
            const lineHeight = fontSize * 1.3;
            const totalHeight = lines.length * lineHeight;
            const startY = height / 2 - totalHeight / 2;
            
            lines.forEach((line, index) => {
                ctx.fillText(line, width / 2, startY + index * lineHeight);
            });
            
            // Reset
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.globalAlpha = 1;
        }

        function drawWatermarkFrame(ctx, width, height) {
            if (!watermarkImage) return;
            
            const opacity = parseInt(document.getElementById('watermarkOpacity').value) / 100;
            const size = parseInt(document.getElementById('watermarkSize').value) / 100;
            
            const watermarkWidth = width * size;
            const watermarkHeight = (watermarkImage.height / watermarkImage.width) * watermarkWidth;
            
            const x = width - watermarkWidth - 30;
            const y = height - watermarkHeight - 30;
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.drawImage(watermarkImage, x, y, watermarkWidth, watermarkHeight);
            ctx.restore();
        }

        function downloadGeneratedVideo(url, story) {
            const a = document.createElement('a');
            a.href = url;
            a.download = `video_${story.slideTitleEN.replace(/\s+/g, '_')}_${story.lineItem.replace(/\s+/g, '_')}_${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function downloadVideo() {
            if (!videoPlayer.src) return;
            
            const a = document.createElement('a');
            a.href = videoPlayer.src;
            a.download = `generated_video_${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showNotification('Video downloaded!');
        }

        function clearVideo() {
            videoPlayer.src = '';
            document.getElementById('generatedVideoSection').style.display = 'none';
        }

        // ==================== UI FUNCTIONS ====================
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected section
            const section = document.getElementById(`${sectionId}-section`);
            if (section) {
                section.classList.add('active');
            }
            
            // Update sidebar active state
            document.querySelectorAll('.sidebar-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Close sidebar on mobile
            if (window.innerWidth <= 768) {
                document.getElementById('sidebar').classList.remove('mobile-visible');
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('mobile-visible');
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.background = type === 'error' ? '#ef4444' : '#10b981';
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            // Story text input
            document.getElementById('storyText').addEventListener('input', function(e) {
                currentStory = e.target.value;
                drawPreview();
            });
            
            // Close settings with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && settingsPanel.classList.contains('active')) {
                    toggleSettings();
                }
            });
            
            // Close sidebar when clicking outside on mobile
            document.addEventListener('click', function(e) {
                if (window.innerWidth <= 768) {
                    const sidebar = document.getElementById('sidebar');
                    if (sidebar.classList.contains('mobile-visible') && 
                        !sidebar.contains(e.target) && 
                        !e.target.classList.contains('mobile-menu-toggle')) {
                        sidebar.classList.remove('mobile-visible');
                    }
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', updateCanvasSize);
        }

        // ==================== INITIALIZE ====================
        document.addEventListener('DOMContentLoaded', init);
    </script>
    <script>

        // ==================== COMPLETE v21.js INLINE SCRIPT ====================
        {
// REPLACE your 2nd script tag with this entire code

// ==================== CONFIGURATION ====================
const videoFormats = [
    { id: 'youtube', name: 'YouTube', width: 1920, height: 1080, icon: 'fab fa-youtube' },
    { id: 'instagram', name: 'Instagram', width: 1080, height: 1080, icon: 'fab fa-instagram' },
    { id: 'facebook', name: 'Facebook', width: 1200, height: 630, icon: 'fab fa-facebook' },
    { id: 'linkedin', name: 'LinkedIn', width: 1200, height: 627, icon: 'fab fa-linkedin' },
    { id: 'twitter', name: 'Twitter', width: 1200, height: 675, icon: 'fab fa-twitter' },
    { id: 'tiktok', name: 'TikTok', width: 1080, height: 1920, icon: 'fab fa-tiktok' },
    { id: 'shorts', name: 'Shorts', width: 1080, height: 1920, icon: 'fas fa-mobile-alt' }
];

// ==================== STATE MANAGEMENT ====================
let currentFormat = 'youtube';
let currentStory = '';
let selectedFormats = []; // Track multiple formats
let currentJsonFileName = 'stories';
let currentStoryData = null; // Track full story object for metadata
let backgroundImage = null;
let watermarkImage = null;
let watermarkList = []; // For round robin
let currentWatermarkIndex = 0;
let audioFile = null;
let audioContext = null;
let audioBuffer = null;
let introFile = null;
let outroFile = null;
let isPreviewPlaying = false;
let previewAnimationId = null;
let stories = [];
// let batchStories = []; // We use unified stories array now
let activeGenerations = 0;
let generationProgress = 0;
let isBatchPaused = false;

// ==================== BURGER MENU SYSTEM ====================
function createBurgerMenu() {
    // Remove existing burger menu if any
    const existingMenu = document.getElementById('burgerMenu');
    if (existingMenu) existingMenu.remove();
    
    const existingToggle = document.getElementById('burgerToggle');
    if (existingToggle) existingToggle.remove();
    
    // Create burger menu container
    const burgerMenu = document.createElement('div');
    burgerMenu.id = 'burgerMenu';
    burgerMenu.style.cssText = `
        position: fixed;
        top: 60px;
        left: 10px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 5px 25px rgba(0,0,0,0.15);
        z-index: 10000;
        display: none;
        flex-direction: column;
        min-width: 250px;
        max-width: 90vw;
        max-height: 80vh;
        overflow-y: auto;
        border: 1px solid #e2e8f0;
    `;
    
    // Menu items with icons and actions
    const menuItems = [
        { icon: 'fas fa-video', text: '🎬 Video Creator', action: () => showSection('creator') },
        { icon: 'fas fa-list', text: '📚 Stories Library', action: () => showSection('stories') },
        { icon: 'fas fa-layer-group', text: '📦 Batch Generate', action: () => showSection('batch') },
        { icon: 'fas fa-file-import', text: '📥 Import JSON', action: () => showSection('import') },
        { icon: 'fas fa-download', text: '💾 Export Videos', action: () => showSection('export') },
        { icon: 'fas fa-music', text: '🎵 Audio Library', action: showAudioLibrary },
        { icon: 'fas fa-images', text: '🖼️ Media Library', action: showMediaLibrary },
        { icon: 'fas fa-sliders-h', text: '⚙️ Settings', action: toggleSettings },
        { icon: 'fas fa-chart-line', text: '📊 Analytics', action: showAnalytics },
        { icon: 'fas fa-question-circle', text: '❓ Help & Support', action: showHelp }
    ];
    
    // Add menu items
    menuItems.forEach(item => {
        const menuItem = document.createElement('button');
        menuItem.style.cssText = `
            padding: 14px 20px;
            border: none;
            background: white;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 15px;
            color: #334155;
            border-bottom: 1px solid #f1f5f9;
        `;
        menuItem.innerHTML = `<i class="${item.icon}" style="width: 20px; color: #64748b;"></i> ${item.text}`;
        menuItem.onmouseenter = () => menuItem.style.background = '#f8fafc';
        menuItem.onmouseleave = () => menuItem.style.background = 'white';
        menuItem.onclick = () => {
            item.action();
            hideBurgerMenu();
        };
        burgerMenu.appendChild(menuItem);
    });
    
    // Add header
    const header = document.createElement('div');
    header.style.cssText = `
        padding: 15px 20px;
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        color: white;
        font-weight: 600;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 10px;
        border-radius: 8px 8px 0 0;
    `;
    header.innerHTML = `<i class="fas fa-bars"></i> Quick Menu`;
    burgerMenu.insertBefore(header, burgerMenu.firstChild);
    
    document.body.appendChild(burgerMenu);
    
    // Create burger toggle button
    const burgerToggle = document.createElement('button');
    burgerToggle.id = 'burgerToggle';
    burgerToggle.innerHTML = '<i class="fas fa-bars"></i>';
    burgerToggle.style.cssText = `
        position: fixed;
        top: 15px;
        left: 15px;
        width: 45px;
        height: 45px;
        border-radius: 10px;
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        color: white;
        border: none;
        font-size: 1.3rem;
        cursor: pointer;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        transition: all 0.3s;
    `;
    burgerToggle.onmouseenter = () => {
        burgerToggle.style.transform = 'scale(1.1)';
        burgerToggle.style.boxShadow = '0 6px 20px rgba(37, 99, 235, 0.4)';
    };
    burgerToggle.onmouseleave = () => {
        burgerToggle.style.transform = 'scale(1)';
        burgerToggle.style.boxShadow = '0 4px 12px rgba(37, 99, 235, 0.3)';
    };
    burgerToggle.onclick = toggleBurgerMenu;
    
    document.body.appendChild(burgerToggle);
    
    // Add overlay for mobile
    const overlay = document.createElement('div');
    overlay.id = 'burgerOverlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.4);
        z-index: 9998;
        display: none;
        backdrop-filter: blur(2px);
    `;
    overlay.onclick = hideBurgerMenu;
    document.body.appendChild(overlay);
}

// Toggle burger menu
function toggleBurgerMenu() {
    const menu = document.getElementById('burgerMenu');
    const overlay = document.getElementById('burgerOverlay');
    const toggle = document.getElementById('burgerToggle');
    
    if (menu.style.display === 'flex') {
        hideBurgerMenu();
    } else {
        showBurgerMenu();
    }
}

function showBurgerMenu() {
    const menu = document.getElementById('burgerMenu');
    const overlay = document.getElementById('burgerOverlay');
    const toggle = document.getElementById('burgerToggle');
    
    menu.style.display = 'flex';
    overlay.style.display = 'block';
    toggle.innerHTML = '<i class="fas fa-times"></i>';
    toggle.style.background = '#ef4444';
}

function hideBurgerMenu() {
    const menu = document.getElementById('burgerMenu');
    const overlay = document.getElementById('burgerOverlay');
    const toggle = document.getElementById('burgerToggle');
    
    menu.style.display = 'none';
    overlay.style.display = 'none';
    toggle.innerHTML = '<i class="fas fa-bars"></i>';
    toggle.style.background = 'linear-gradient(135deg, #2563eb, #3b82f6)';
}

// ==================== FORMAT & PREVIEW SYSTEM ====================
function setupFormats() {
    const formatGrid = document.getElementById('formatGrid');
    if (!formatGrid) return;
    
    formatGrid.innerHTML = '';
    
    videoFormats.forEach(format => {
        const card = document.createElement('div');
        card.className = `format-card ${format.id === currentFormat ? 'active' : ''}`;
        card.onclick = () => selectFormat(format.id);
        
        card.innerHTML = `
            <div style="position: absolute; top: 8px; right: 8px; z-index: 5;">
                <input type="checkbox" ${selectedFormats.includes(format.id) ? 'checked' : ''} 
                       onclick="event.stopPropagation(); toggleFormatSelection('${format.id}')" style="width: 16px; height: 16px; cursor: pointer;">
            </div>
            <div class="format-icon">
                <i class="${format.icon}"></i>
            </div>
            <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.25rem;">
                ${format.name}
            </div>
            <div style="font-size: 0.75rem; color: #64748b;">
                ${format.width}×${format.height}
            </div>
        `;
        
        formatGrid.appendChild(card);
    });
}

function selectFormat(formatId) {
    currentFormat = formatId;
    setupFormats();
    updateCanvasSize();
    drawPreview();
    saveSettings();
}

function toggleFormatSelection(id) {
    if (selectedFormats.includes(id)) {
        selectedFormats = selectedFormats.filter(f => f !== id);
    } else {
        selectedFormats.push(id);
    }
    setupFormats(); // Re-render to update checkbox UI
    saveSettings();
}

function updateCanvasSize() {
    const canvas = document.getElementById('videoCanvas');
    if (!canvas) return;
    
    const format = videoFormats.find(f => f.id === currentFormat);
    if (!format) return;
    
    const containerWidth = canvas.parentElement.clientWidth - 48;
    const scale = containerWidth / format.width;
    
    canvas.width = format.width;
    canvas.height = format.height;
    
    // CSS scaling for display
    canvas.style.width = `${format.width * scale}px`;
    canvas.style.height = `${format.height * scale}px`;
}

function drawPreview(time = 0) {
    const canvas = document.getElementById('videoCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const format = videoFormats.find(f => f.id === currentFormat);
    if (!format) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background
    if (backgroundImage) {
        drawImageProp(ctx, backgroundImage, 0, 0, canvas.width, canvas.height);
    } else {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#2563eb');
        gradient.addColorStop(1, '#7c3aed');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    // Draw story text
    // Use currentStory from state or textarea
    const textToDraw = currentStory || document.getElementById('storyText')?.value || '';
    drawStoryFrame(ctx, textToDraw, time, canvas.width, canvas.height);
    
    // Draw watermark if enabled
    if (document.getElementById('addWatermark')?.checked && watermarkImage) {
        drawWatermarkFrame(ctx, canvas.width, canvas.height);
    }
    
    // Draw Safe Zones if enabled (Preview Only)
    if (document.getElementById('showSafeZones')?.checked) {
        drawSafeZones(ctx, canvas.width, canvas.height);
    }
}

function playPreview() {
    if (isPreviewPlaying) return;
    
    isPreviewPlaying = true;
    const startTime = Date.now();
    
    function animate() {
        if (!isPreviewPlaying) return;
        
        const currentTime = (Date.now() - startTime) / 1000;
        drawPreview(currentTime);
        previewAnimationId = requestAnimationFrame(animate);
    }
    
    animate();
}

function stopPreview() {
    isPreviewPlaying = false;
    if (previewAnimationId) {
        cancelAnimationFrame(previewAnimationId);
    }
    drawPreview(0);
}

// Expose to window for HTML buttons
window.playPreview = playPreview;
window.stopPreview = stopPreview;
window.drawPreview = drawPreview;

// ==================== AUDIO SYSTEM ====================
function setupAudioContext() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        console.warn('Web Audio API not supported:', e);
    }
}

function uploadAudio() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/*';
    input.onchange = (e) => handleAudioUpload(e.target.files[0]);
    input.click();
}

function uploadIntro() { document.getElementById('introUpload').click(); }
function handleIntroUpload(file) { 
    if(file) {
        introFile = file; 
        document.getElementById('introStatus').textContent = 'Loaded';
        showNotification('Intro video loaded!'); 
    }
}

function uploadOutro() { document.getElementById('outroUpload').click(); }
function handleOutroUpload(file) { 
    if(file) {
        outroFile = file; 
        document.getElementById('outroStatus').textContent = 'Loaded';
        showNotification('Outro video loaded!'); 
    }
}

function handleAudioUpload(file) {
    if (!file) return;
    
    const url = URL.createObjectURL(file);
    audioFile = new Audio(url);
    audioFile.volume = document.getElementById('audioVolume') ? 
        document.getElementById('audioVolume').value / 100 : 0.8;
    
    // Setup audio visualization
    if (audioContext) {
        const reader = new FileReader();
        reader.onload = function(e) {
            audioContext.decodeAudioData(e.target.result, function(buffer) {
                audioBuffer = buffer;
            });
        };
        reader.readAsArrayBuffer(file);
    }
    
    showNotification('Audio uploaded successfully! Audio will play with video.');
}

function handleWatermarkFolderUpload(event) {
    const files = Array.from(event.target.files).filter(f => f.type.startsWith('image/'));
    if (files.length === 0) {
        showNotification('No images found in folder', 'warning');
        return;
    }
    
    watermarkList = [];
    let loaded = 0;
    files.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
    
    files.forEach(file => {
        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = () => { loaded++; };
        watermarkList.push(img);
    });
    
    showNotification(`Loaded ${files.length} watermarks for Round Robin`);
}

// ==================== JSON IMPORT SYSTEM ====================
const libraryFiles = [
    { name: "Full English", path: "assets/posters/2026-bmc/manifesto_stories_en.json" },
    { name: "Full Hindi", path: "assets/posters/2026-bmc/manifesto_stories_hi.json" },
    { name: "Full Marathi", path: "assets/posters/2026-bmc/manifesto_stories_mr.json" },
    { name: "Page 1 (Hindi)", path: "assets/posters/2026-bmc/manifesto_stories_hi_page_1.json" },
    { name: "Page 1 (Marathi)", path: "assets/posters/2026-bmc/manifesto_stories_mr_page_1.json" },
    { name: "Page 2 (Hindi)", path: "assets/posters/2026-bmc/manifesto_stories_hi_page_2.json" },
    { name: "Page 2 (Marathi)", path: "assets/posters/2026-bmc/manifesto_stories_mr_page_2.json" },
    { name: "Page 3 (Hindi)", path: "assets/posters/2026-bmc/manifesto_stories_hi_page_3.json" },
    { name: "Page 3 (Marathi)", path: "assets/posters/2026-bmc/manifesto_stories_mr_page_3.json" },
    { name: "Page 4 (Hindi)", path: "assets/posters/2026-bmc/manifesto_stories_hi_page_4.json" },
    { name: "Page 4 (Marathi)", path: "assets/posters/2026-bmc/manifesto_stories_mr_page_4.json" },
    { name: "Page 7 (Hindi)", path: "assets/posters/2026-bmc/manifesto_stories_hi_page_7.json" },
    { name: "Page 7 (Marathi)", path: "assets/posters/2026-bmc/manifesto_stories_mr_page_7.json" },
    { name: "Page 9 (Hindi)", path: "assets/posters/2026-bmc/manifesto_stories_hi_page_9.json" },
    { name: "Page 9 (Marathi)", path: "assets/posters/2026-bmc/manifesto_stories_mr_page_9.json" },
];

function populateQuickLoadLibrary() {
    const container = document.getElementById('quickLoadButtons');
    if (!container) return;
    
    container.innerHTML = '';
    libraryFiles.forEach(file => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-sm btn-secondary';
        btn.style.fontSize = '0.85rem';
        btn.style.justifyContent = 'flex-start';
        btn.style.textAlign = 'left';
        btn.innerHTML = `<i class="fas fa-file-alt"></i> ${file.name}`;
        btn.onclick = () => window.SmartVideoGenerator.loadJSONFromPath(file.path);
        container.appendChild(btn);
    });
}

function resetStories() {
    if(confirm('Are you sure you want to clear all stories and reset to sample data?')) {
        loadSampleJSON();
        showNotification('Stories reset to sample data.');
    }
}

function handleFolderLibraryUpload(event) {
    const files = Array.from(event.target.files).filter(f => f.name.toLowerCase().endsWith('.json'));
    const container = document.getElementById('quickLoadButtons');
    
    if (!container) return;
    
    if (files.length === 0) {
        showNotification('No JSON files found in selected folder.', 'warning');
        return;
    }
    
    container.innerHTML = '';
    
    // Sort files naturally
    files.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
    
    files.forEach(file => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-sm btn-secondary';
        btn.style.fontSize = '0.85rem';
        btn.style.justifyContent = 'flex-start';
        btn.style.textAlign = 'left';
        btn.innerHTML = `<i class="fas fa-file-alt"></i> ${file.name}`;
        btn.onclick = () => {
            const reader = new FileReader();
            currentJsonFileName = file.name.replace(/\.[^/.]+$/, "");
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    if (jsonData.stories && Array.isArray(jsonData.stories)) {
                        stories = jsonData.stories;
                        renderStoriesList();
                        document.getElementById('importedStories').style.display = 'block';
                        document.getElementById('storyCount').textContent = stories.length;
                        showNotification(`Loaded ${stories.length} stories from ${file.name}`);
                        renderBatchStoriesList();
                    } else {
                        showNotification('Invalid JSON format.', 'error');
                    }
                } catch (error) {
                    showNotification('Error parsing JSON: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        };
        container.appendChild(btn);
    });
    
    showNotification(`Library updated with ${files.length} files from folder.`);
}

function setupJSONImport() {
    // Create import section if it doesn't exist
    if (!document.getElementById('import-section')) {
        const importSection = document.createElement('div');
        importSection.id = 'import-section';
        importSection.className = 'section';
        importSection.innerHTML = `
            <h2 style="margin-bottom: 1.5rem;">Import JSON Data</h2>
            <div class="json-import">
                <i class="fas fa-file-code"></i>
                <h3>Import Your Stories</h3>
                <p>Upload a JSON file containing your stories data</p>
                <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('jsonFileInput').click()">
                    <i class="fas fa-upload"></i> Choose JSON File
                </button>
                <div style="margin-top: 1rem; display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="loadSampleJSON()">
                        <i class="fas fa-download"></i> Load Sample JSON
                    </button>
                    <button class="btn btn-info" onclick="document.getElementById('folderInput').click()">
                        <i class="fas fa-folder-open"></i> Scan Folder
                    </button>
                    <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
                </div>
            </div>
            <div id="importedStories" style="display: none; margin-top: 2rem;">
                <h3>Imported Stories (<span id="storyCount">0</span>)</h3>
                <div class="stories-list" id="importedStoriesList">
                    <!-- Imported stories will appear here -->
                </div>
            </div>
        `;
        
        const contentArea = document.querySelector('.content-area');
        if (contentArea) {
            contentArea.appendChild(importSection);
        }
    }
    
    // Add event listeners (run regardless of creation)
    setTimeout(() => {
        const fileInput = document.getElementById('jsonFileInput');
        if (fileInput) {
            fileInput.addEventListener('change', handleJSONFileUpload);
        }
        
        const folderInput = document.getElementById('folderInput');
        if (folderInput) {
            folderInput.addEventListener('change', handleFolderLibraryUpload);
        }
        
        populateQuickLoadLibrary();
    }, 100);
}

function handleJSONFileUpload(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;
    
    const appendMode = document.getElementById('appendStories')?.checked;
    
    if (!appendMode) {
        stories = []; // Clear if not appending
    }
    
    let processedCount = 0;
    let newStoriesTotal = 0;

    files.forEach((file, index) => {
        const reader = new FileReader();
        const filename = file.name.replace(/\.[^/.]+$/, "");
        
        reader.onload = function(e) {
            try {
                const jsonData = JSON.parse(e.target.result);
                if (jsonData.stories && Array.isArray(jsonData.stories)) {
                    // Tag stories with source filename
                    const newStories = jsonData.stories.map(s => ({
                        ...s,
                        sourceFile: filename
                    }));
                    
                    stories = [...stories, ...newStories];
                    newStoriesTotal += newStories.length;
                    
                    // If replacing, set global filename to the first file
                    if (!appendMode && index === 0) {
                        currentJsonFileName = filename;
                    }
                }
            } catch (error) {
                console.error(`Error parsing ${file.name}:`, error);
                showNotification(`Error parsing ${file.name}`, 'error');
            }
            
            processedCount++;
            
            if (processedCount === files.length) {
                renderStoriesList();
                document.getElementById('importedStories').style.display = 'block';
                document.getElementById('storyCount').textContent = stories.length;
                renderBatchStoriesList();
                
                const action = appendMode ? "Appended" : "Imported";
                showNotification(`${action} ${newStoriesTotal} stories from ${files.length} file(s)!`);
            }
        };
        reader.readAsText(file);
    });
    
    event.target.value = '';
}

async function loadJSONFromPath(path) {
    try {
        const response = await fetch(path);
        const filename = path.split('/').pop().replace(/\.[^/.]+$/, ""); // Extract filename
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const jsonData = await response.json();
        
        if (jsonData.stories && Array.isArray(jsonData.stories)) {
            const newStories = jsonData.stories.map(s => ({
                ...s,
                sourceFile: filename
            }));

            const appendMode = document.getElementById('appendStories')?.checked;
            
            if (appendMode) {
                stories = [...stories, ...newStories];
                showNotification(`Appended ${newStories.length} stories from ${filename}`);
            } else {
                stories = newStories;
                currentJsonFileName = filename;
                showNotification(`Loaded ${stories.length} stories from ${filename}`);
            }
            
            renderStoriesList();
            
            document.getElementById('importedStories').style.display = 'block';
            document.getElementById('storyCount').textContent = stories.length;
            
            renderBatchStoriesList();
        } else {
            showNotification('Invalid JSON format.', 'error');
        }
    } catch (e) {
        console.error("Load JSON Error:", e);
        if (window.location.protocol === 'file:') {
            showNotification('⚠️ Security Restriction: Library buttons require a local server. Please use "Scan Folder" or "Choose JSON File" buttons instead.', 'error');
        } else {
            showNotification('Error loading JSON: ' + e.message, 'error');
        }
    }
}

function loadSampleJSON() {
    const sampleJSON = {
        "stories": [
            {
                "id": 1,
                "slideNumber": 7,
                "slideTitleEN": "Accident Free Mumbai",
                "lineItem": "Pothole Free City",
                "story": "We are committed to making Mumbai city pothole-free. We will ensure the concretization of all major and minor roads to ensure smooth and safe travel for everyone.",
                "status": "ready",
                "videoDuration": 15
            },
            {
                "id": 2,
                "slideNumber": 7,
                "slideTitleEN": "Accident Free Mumbai",
                "lineItem": "Strict Action",
                "story": "We will take strict action against contractors doing substandard work and conduct thorough inquiries into corruption in road works.",
                "status": "ready",
                "videoDuration": 15
            },
            {
                "id": 3,
                "slideNumber": 7,
                "slideTitleEN": "Pollution Free Mumbai",
                "lineItem": "Clean Air Rights",
                "story": "Clean air is a fundamental right of every Mumbaikar. We will implement real-time air quality monitoring to ensure a healthier environment.",
                "status": "ready",
                "videoDuration": 15
            },
            {
                "id": 4,
                "slideNumber": 7,
                "slideTitleEN": "Pollution Free Mumbai",
                "lineItem": "Construction Control",
                "story": "We will enforce strict controls on pollution caused by construction and take immediate action during severe AQI conditions.",
                "status": "ready",
                "videoDuration": 15
            }
        ]
    };
    
    stories = sampleJSON.stories;
    renderStoriesList();
    renderBatchStoriesList();
    
    document.getElementById('importedStories').style.display = 'block';
    document.getElementById('storyCount').textContent = stories.length;
    showNotification(`Loaded ${stories.length} sample stories!`);
}

// ==================== PROGRESS BAR SYSTEM ====================
function setupProgressBars() {
    // Create generation progress bar if it doesn't exist
    if (!document.getElementById('generationProgress')) {
        const progressContainer = document.createElement('div');
        progressContainer.id = 'generationProgress';
        progressContainer.className = 'progress-container';
        progressContainer.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            z-index: 10000;
            display: none;
        `;
        
        progressContainer.innerHTML = `
            <div class="progress-header">
                <span><i class="fas fa-film"></i> Generating Video</span>
                <span id="generationPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="generationProgressFill" style="width: 0%;"></div>
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #64748b; text-align: center;">
                <i class="fas fa-info-circle"></i> Status: <span id="audioStatus">Preparing...</span>
            </div>
        `;
        
        document.body.appendChild(progressContainer);
    }
}

function updateGenerationProgress(percent, message = '') {
    const progressFill = document.getElementById('generationProgressFill');
    const percentText = document.getElementById('generationPercent');
    const statusText = document.getElementById('audioStatus');
    const progressBar = document.getElementById('generationProgress');
    
    if (progressFill && percentText) {
        progressFill.style.width = `${percent}%`;
        percentText.textContent = `${Math.round(percent)}%`;
        
        if (message && statusText) {
            statusText.textContent = message;
        }
        
        if (percent > 0 && percent < 100) {
            progressBar.style.display = 'block';
        } else if (percent >= 100) {
            setTimeout(() => {
                progressBar.style.display = 'none';
            }, 2000);
        }
    }
}

function playVideoClip(file, ctx, width, height, audioCtx, dest) {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.crossOrigin = "anonymous";
        
        // Setup Audio Routing
        let source = null;
        if (audioCtx && dest) {
            video.muted = false;
            source = audioCtx.createMediaElementSource(video);
            source.connect(dest);
            source.connect(audioCtx.destination); // Monitor audio
        } else {
            video.muted = true; // Mute if no destination to prevent speaker bleed
        }
        
        video.onended = () => {
            if (source) source.disconnect();
            resolve();
        };
        
        video.onloadedmetadata = () => {
            video.play().then(() => {
                const draw = () => {
                    if (video.paused || video.ended) return;
                    drawImageProp(ctx, video, 0, 0, width, height);
                    requestAnimationFrame(draw);
                };
                draw();
            }).catch(e => { console.warn("Clip play error", e); resolve(); });
        };
        video.onerror = () => resolve();
    });
}

// ==================== VIDEO GENERATION WITH AUDIO ====================
function generateVideoWithAudio(targetFormatId = null) {
    // Removed isGenerating check to allow parallel execution
    
    return new Promise(async (resolve, reject) => {
        activeGenerations++;
        let isRunning = true; // Local flag for this generation instance
        updateGenerationProgress(0, 'Preparing video...');
        
        // Safety Timeout to prevent batch hanging
        const timeoutId = setTimeout(() => {
            if (isRunning) {
                console.warn('Video generation timed out');
                showNotification('Generation timed out for ' + (targetFormatId || currentFormat), 'warning');
                if (typeof mediaRecorder !== 'undefined' && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                } else {
                    cleanupAndResolve(null);
                }
            }
        }, 45000); // 45 seconds timeout
        
        // Ensure currentStory is set (critical for batch processing)
        if (!currentStory && document.getElementById('storyText')) {
            currentStory = document.getElementById('storyText').value;
        }
        
        // Pause any currently playing video to avoid audio overlap
        const videoPlayer = document.getElementById('videoPlayer');
        if (videoPlayer) {
            videoPlayer.pause();
        }
        
        const cleanupAndResolve = (result) => {
            clearTimeout(timeoutId);
            isRunning = false;
            activeGenerations--;
            resolve(result);
        };
    
        try {
            const formatId = targetFormatId || currentFormat;
            const format = videoFormats.find(f => f.id === formatId);
            if (!format) throw new Error('Invalid format');
            
            // Create offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = format.width;
            offscreenCanvas.height = format.height;
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
            
            updateGenerationProgress(10, 'Setting up recorder...');
            
            // Setup Audio Context & Destination (Global for this generation session)
            let dest = null;
            const stream = offscreenCanvas.captureStream(30);
            let combinedStream = stream;
            
            if (document.getElementById('includeAudio')?.checked) {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') await audioContext.resume();
                dest = audioContext.createMediaStreamDestination();
                
                const audioTrack = dest.stream.getAudioTracks()[0];
                if (audioTrack) {
                    combinedStream = new MediaStream([...stream.getVideoTracks(), audioTrack]);
                }
            }
            
            // Determine Audio Source (Hierarchical: Story Specific > Global)
            let audioSource = audioFile;
            let isStoryAudio = false;
            
            // Clone global audio to support parallel generation
            if (audioSource && audioSource === audioFile) {
                 const clonedAudio = new Audio(audioSource.src);
                 clonedAudio.crossOrigin = "anonymous";
                 clonedAudio.volume = audioSource.volume;
                 audioSource = clonedAudio;
            }
            
            if (currentStoryData && currentStoryData.audio) {
                try {
                    // Attempt to load story-specific audio
                    // Note: This assumes the path is accessible. 
                    // For a robust implementation, we might need to preload or handle async loading better.
                    // Here we create a temporary audio element.
                    audioSource = new Audio(currentStoryData.audio);
                    audioSource.volume = document.getElementById('audioVolume') ? document.getElementById('audioVolume').value / 100 : 0.8;
                    isStoryAudio = true;
                } catch (e) { console.warn("Failed to load story audio", e); }
            }
            
            // Determine Watermark (Hierarchical: Story Specific > Global)
            let activeWatermark = watermarkImage;
            if (currentStoryData && currentStoryData.watermark) {
                await new Promise(resolve => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => { activeWatermark = img; resolve(); };
                    img.onerror = () => { console.warn('Failed to load story watermark, using default'); resolve(); };
                    img.src = currentStoryData.watermark;
                });
            } else if (watermarkList.length > 0) {
                // Round Robin if no specific story watermark
                activeWatermark = watermarkList[currentWatermarkIndex % watermarkList.length];
                currentWatermarkIndex++;
            }

            // Detect supported mime type
            const mimeTypes = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm',
                'video/mp4'
            ];
            let selectedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));
            
            const options = {
                videoBitsPerSecond: 2500000 // 2.5 Mbps
            };
            
            if (selectedMimeType) {
                options.mimeType = selectedMimeType;
            }

            let mediaRecorder;
            try {
                mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                console.warn('MediaRecorder creation failed with options, trying default', e);
                mediaRecorder = new MediaRecorder(combinedStream);
            }
            
            const chunks = [];
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) {
                    chunks.push(e.data);
                }
            };
            
            mediaRecorder.onerror = (e) => {
                console.error('MediaRecorder error:', e);
                showNotification('Recording error: ' + (e.error ? e.error.name : 'Unknown'), 'error');
                cleanupAndResolve(null);
            };
            
            mediaRecorder.onstop = async () => {
                const totalSize = chunks.reduce((acc, chunk) => acc + chunk.size, 0);
                
                if (totalSize <= 0) { 
                    console.error('Generated video is empty. Chunks:', chunks);
                    showNotification('Generation failed: Video was empty (0 bytes). Try again.', 'error');
                    updateGenerationProgress(0, 'Failed');
                    cleanupAndResolve(null);
                    return;
                }

                const blob = new Blob(chunks, { 
                    type: selectedMimeType || 'video/webm'
                });
                
                const url = URL.createObjectURL(blob);
                
                // Show video player
                const videoPlayer = document.getElementById('videoPlayer');
                const generatedVideoSection = document.getElementById('generatedVideoSection');
                
                if (videoPlayer) {
                    videoPlayer.src = url;
                    // Removed auto-play to prevent audio overlap in batch
                }
                if (generatedVideoSection) {
                    generatedVideoSection.style.display = 'block';
                }
                
                // Update progress to 100% immediately
                updateGenerationProgress(100, 'Video complete!');
                showNotification('Video generated successfully!');
                
                // Construct Descriptive Filename
                let sourceName = currentJsonFileName || 'stories';
                if (currentStoryData && currentStoryData.sourceFile) {
                    sourceName = currentStoryData.sourceFile;
                }
                const safeJsonName = sourceName.replace(/[^a-z0-9]/gi, '_');
                const storyId = (currentStoryData && currentStoryData.id !== undefined) ? currentStoryData.id : Date.now().toString().slice(-4);
                const platform = formatId || 'video';
                
                let description = 'story';
                if (currentStoryData) {
                    if (currentStoryData.lineItem) description = currentStoryData.lineItem;
                    else if (currentStoryData.slideTitleEN) description = currentStoryData.slideTitleEN;
                }
                const safeDescription = description.replace(/[^a-z0-9]/gi, '_');
                const filename = `${platform}_${safeJsonName}_${storyId}_${safeDescription}.webm`;
                
                // Auto-download if enabled
                if (document.getElementById('autoDownload')?.checked) {
                    try {
                        downloadVideo(url, filename);
                        
                        if (document.getElementById('generateMetadata')?.checked) {
                            const metadata = {
                                video_file: filename,
                                title: currentStoryData?.slideTitleEN ? `${currentStoryData.slideTitleEN} - ${currentStoryData.lineItem}` : 'Manifesto Video',
                                description: (currentStory || '').replace(/<[^>]*>/g, ''),
                                tags: ["Manifesto", "Mumbai", "2026", safeJsonName],
                                platform: platform,
                                generated_at: new Date().toISOString(),
                                upload_status: "pending"
                            };
                            setTimeout(() => {
                                downloadMetadata(metadata, filename.replace(/\.webm$/, '.json'));
                            }, 500);
                        }
                    } catch (e) {
                        console.error("Auto-download failed", e);
                    }
                }
                
                cleanupAndResolve(url);
            };
            
            // Start recording
            updateGenerationProgress(20, 'Starting recording...');
            
            // Draw one frame before starting to ensure stream is active
            if (backgroundImage) {
                drawImageProp(offscreenCtx, backgroundImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
            } else {
                offscreenCtx.fillStyle = '#2563eb';
                offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            }
            
            // Use standard start without timeslice to buffer entire video (more robust for short videos)
            mediaRecorder.start(); 
            
            // PHASE 1: INTRO
            if (introFile) {
                updateGenerationProgress(5, 'Playing Intro...');
                await playVideoClip(introFile, offscreenCtx, offscreenCanvas.width, offscreenCanvas.height, audioContext, dest);
            }
            
            // PHASE 2: MAIN CONTENT
            // Play background audio if included
            if (audioSource && dest) {
                try {
                    if (!audioSource._source) {
                        audioSource._source = audioContext.createMediaElementSource(audioSource);
                    }
                    audioSource._source.disconnect();
                    audioSource._source.connect(dest);
                    if (!document.getElementById('muteDuringGeneration')?.checked) {
                        audioSource._source.connect(audioContext.destination);
                    }
                    
                    audioSource.currentTime = 0;
                    await audioSource.play();
                    updateGenerationProgress(30, 'Audio playing...');
                } catch (e) {
                    console.warn('Audio play failed:', e);
                }
            }
            
            // Use duration from story if available, else default
            const duration = (currentStoryData && currentStoryData.videoDuration) ? currentStoryData.videoDuration : 15;
            const fps = 30;
            const totalFrames = duration * fps;
            
            // Generate frames
            for (let frame = 0; frame < totalFrames; frame++) {
                if (!isRunning) break;
                
                const time = frame / fps;
                const progress = 30 + (frame / totalFrames) * 65;
                
                // Update progress
                updateGenerationProgress(progress, `Rendering frame ${frame + 1}/${totalFrames}`);
                
                // Draw frame
                offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                
                // Draw background
                if (backgroundImage) {
                    let x = 0, y = 0, w = offscreenCanvas.width, h = offscreenCanvas.height;
                    if (document.getElementById('enableKenBurns')?.checked) {
                        const animationProgress = frame / totalFrames;
                        const scale = 1 + (0.15 * animationProgress);
                        w = offscreenCanvas.width * scale;
                        h = offscreenCanvas.height * scale;
                        x = (offscreenCanvas.width - w) / 2;
                        y = (offscreenCanvas.height - h) / 2;
                    }
                    drawImageProp(offscreenCtx, backgroundImage, x, y, w, h);
                } else {
                    const gradient = offscreenCtx.createLinearGradient(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                    gradient.addColorStop(0, '#2563eb');
                    gradient.addColorStop(1, '#7c3aed');
                    offscreenCtx.fillStyle = gradient;
                    offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                }
                
                // Draw story text
                // Ensure we pass the text string, not the object
                const textToDraw = (typeof currentStory === 'object') ? currentStory.story : currentStory;
                drawStoryFrame(offscreenCtx, textToDraw, time, offscreenCanvas.width, offscreenCanvas.height);
                
                // Draw watermark if enabled
                if (document.getElementById('addWatermark')?.checked && activeWatermark) {
                    drawWatermarkFrame(offscreenCtx, offscreenCanvas.width, offscreenCanvas.height, activeWatermark);
                }
                
                // Wait for next frame
                await new Promise(resolve => setTimeout(resolve, 1000 / fps));
            }
            
            // PHASE 3: OUTRO
            if (outroFile) {
                updateGenerationProgress(90, 'Playing Outro...');
                await playVideoClip(outroFile, offscreenCtx, offscreenCanvas.width, offscreenCanvas.height, audioContext, dest);
            }
            
            // Stop recording
            updateGenerationProgress(95, 'Stopping recording...');
            mediaRecorder.stop();
            
            // Stop audio
            if (audioSource) {
                audioSource.pause();
                audioSource.currentTime = 0;
            }
            
        } catch (error) {
            console.error('Video generation error:', error);
            updateGenerationProgress(0, 'Error occurred');
            showNotification('Error generating video: ' + error.message, 'error');
            cleanupAndResolve(null);
        }
    });
}

// Wrapper for Single Video Generation Button
async function generateVideo() {
    const formats = selectedFormats.length > 0 ? selectedFormats : [currentFormat];
    const performanceMode = document.getElementById('performanceMode')?.checked;
    const CONCURRENCY_LIMIT = performanceMode ? 1 : 7;
    
    if (formats.length > 1) showNotification(`Generating for ${formats.length} platforms...`);

    // Process formats in chunks to respect concurrency limit
    for (let i = 0; i < formats.length; i += CONCURRENCY_LIMIT) {
        const chunk = formats.slice(i, i + CONCURRENCY_LIMIT);
        await Promise.all(chunk.map(fmt => generateVideoWithAudio(fmt)));
    }
}

function toggleBatchPause() {
    isBatchPaused = !isBatchPaused;
    const btn = document.getElementById('pauseBatchBtn');
    if (btn) {
        if (isBatchPaused) {
            btn.innerHTML = '<i class="fas fa-play"></i> Resume Batch';
            btn.className = 'btn btn-primary';
            showNotification('Batch paused.');
        } else {
            btn.innerHTML = '<i class="fas fa-pause"></i> Pause Batch';
            btn.className = 'btn btn-warning';
            showNotification('Batch resumed.');
        }
    }
}

function filterBatchStories(status) {
    const list = document.getElementById('batchStoriesList');
    if (!list) return;
    const items = list.querySelectorAll('.story-item');
    items.forEach(item => {
        // Keep header visible
        if (item.querySelector('#selectAllCheckbox')) return;
        
        const itemStatus = item.getAttribute('data-status');
        if (itemStatus) {
             if (status === 'all' || itemStatus === status) {
                 item.style.display = 'block';
             } else {
                 item.style.display = 'none';
             }
        }
    });
}

// ==================== BATCH GENERATION ====================
async function startBatchGeneration(retryList = null) {
    let selectedStories;
    if (retryList && Array.isArray(retryList)) {
        selectedStories = retryList;
    } else {
        selectedStories = Array.from(document.querySelectorAll('.story-checkbox:checked'))
            .map(cb => parseInt(cb.value));
    }
    
    if (selectedStories.length === 0) {
        showNotification('Please select stories for batch generation.', 'error');
        return;
    }
    
    const batchProgressBar = document.getElementById('batchProgress');
    const batchProgressFill = document.getElementById('batchProgressFill');
    const batchPercentText = document.getElementById('batchPercent');
    const batchETRText = document.getElementById('batchETR');
    
    // Reset pause state
    isBatchPaused = false;
    
    // Add/Reset Pause Button
    let pauseBtn = document.getElementById('pauseBatchBtn');
    if (!pauseBtn) {
        pauseBtn = document.createElement('button');
        pauseBtn.id = 'pauseBatchBtn';
        pauseBtn.className = 'btn btn-warning';
        pauseBtn.style.marginTop = '10px';
        pauseBtn.style.width = '100%';
        pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause Batch';
        pauseBtn.onclick = toggleBatchPause;
        batchProgressBar.appendChild(pauseBtn);
    } else {
        pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause Batch';
        pauseBtn.className = 'btn btn-warning';
        pauseBtn.style.display = 'block';
    }
    
    if (batchProgressBar) batchProgressBar.style.display = 'block';
    if (batchProgressFill) batchProgressFill.style.width = '0%';
    if (batchPercentText) batchPercentText.textContent = '0%';
    
    // Clear previous generated controls ONLY if not retrying
    if (!retryList) {
        document.querySelectorAll('.batch-controls-generated').forEach(el => el.remove());
        const retryBtn = document.getElementById('retryFailedBtn');
        if (retryBtn) retryBtn.style.display = 'none';
        const selectFailedBtn = document.getElementById('selectFailedBtn');
        if (selectFailedBtn) selectFailedBtn.style.display = 'none';
    }
    
    const formats = selectedFormats.length > 0 ? selectedFormats : [currentFormat];
    const performanceMode = document.getElementById('performanceMode')?.checked;
    const CONCURRENCY_LIMIT = performanceMode ? 2 : 7;
    
    const total = selectedStories.length * formats.length;
    let completed = 0;
    const startTime = Date.now();
    let failedStories = [];
    
    if (batchETRText) batchETRText.textContent = 'Calculating time...';
    
    for (const storyId of selectedStories) {
        while (isBatchPaused) {
            if (batchETRText) batchETRText.textContent = 'Batch Paused...';
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        const story = stories.find(s => s.id === storyId);
        if (!story) continue;
        
        // Generate video for this story
        currentStory = story.story;
        currentStoryData = story; // Set full object for metadata
        
        // Auto-load background image for batch
        await new Promise((resolve) => {
            const imgPath = `assets/posters/2026-bmc/page_${story.slideNumber}.jpg`;
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                backgroundImage = img;
                resolve();
            };
            img.onerror = () => {
                // If image fails, clear background or keep previous? Let's clear to avoid mismatch
                backgroundImage = null;
                resolve();
            };
            img.src = imgPath;
        });

        let videoUrls = new Array(formats.length);
        
        // Process formats in chunks to respect concurrency limit
        for (let i = 0; i < formats.length; i += CONCURRENCY_LIMIT) {
            const chunk = formats.slice(i, i + CONCURRENCY_LIMIT);
            const chunkPromises = chunk.map((fmt, idx) => {
                const originalIndex = i + idx;
                return generateVideoWithAudio(fmt).then(url => {
                    videoUrls[originalIndex] = url;
                });
            });
            await Promise.all(chunkPromises);
        }
        
        let storyHasFailure = false;
        videoUrls.forEach((videoUrl, index) => {
            const fmt = formats[index];
            if (videoUrl) {
                const checkbox = document.querySelector(`.story-checkbox[value="${storyId}"]`);
                if (checkbox) {
                    const storyContentDiv = checkbox.nextElementSibling;
                    if (storyContentDiv) {
                        let controlsDiv = storyContentDiv.querySelector('.batch-controls-generated');
                        if (!controlsDiv) {
                            controlsDiv = document.createElement('div');
                            controlsDiv.className = 'batch-controls-generated';
                            controlsDiv.style.marginTop = '8px';
                            controlsDiv.style.display = 'flex';
                            controlsDiv.style.gap = '5px';
                            controlsDiv.style.flexWrap = 'wrap';
                            storyContentDiv.appendChild(controlsDiv);
                        }
                        
                        // Check if button already exists (for retry scenarios)
                        const existingBtn = Array.from(controlsDiv.children).find(btn => btn.textContent.includes(`Play ${fmt}`));
                        if (!existingBtn) {
                            const playBtn = document.createElement('button');
                            playBtn.className = 'btn btn-sm btn-secondary';
                            playBtn.style.padding = '2px 8px';
                            playBtn.style.fontSize = '12px';
                            playBtn.innerHTML = `<i class="fas fa-play"></i> Play ${fmt}`;
                            playBtn.onclick = (e) => {
                                e.stopPropagation();
                                const player = document.getElementById('videoPlayer');
                                if (player) {
                                    player.src = videoUrl;
                                    player.play();
                                    document.getElementById('generatedVideoSection').style.display = 'block';
                                    document.getElementById('generatedVideoSection').scrollIntoView({ behavior: 'smooth' });
                                }
                            };
                            controlsDiv.appendChild(playBtn);
                        }
                    }
                }
            } else {
                storyHasFailure = true;
            }
        });
        
        if (storyHasFailure) {
            failedStories.push(storyId);
            story.status = 'failed';
        } else {
            story.status = 'produced';
        }
        
        // Update DOM status for filtering
        const checkbox = document.querySelector(`.story-checkbox[value="${storyId}"]`);
        const storyRow = checkbox ? checkbox.closest('.story-item') : null;
        if (storyRow) {
            storyRow.setAttribute('data-status', story.status);
            const badge = storyRow.querySelector('.status-badge');
            if (badge) {
                badge.className = `status-badge status-${story.status}`;
                badge.textContent = story.status;
            }
        }
        
        // Update batch progress (count all formats for this story as done)
        completed += formats.length;
        const progress = Math.round((completed / total) * 100);
        if (batchProgressFill) batchProgressFill.style.width = `${progress}%`;
        if (batchPercentText) batchPercentText.textContent = `${progress}%`;
        
        // Calculate ETR
        if (batchETRText && completed > 0) {
            const elapsed = Date.now() - startTime;
            const avgTimePerItem = elapsed / completed;
            const remainingItems = total - completed;
            const remainingTimeMs = avgTimePerItem * remainingItems;
            
            const seconds = Math.ceil(remainingTimeMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const remSeconds = seconds % 60;
            
            batchETRText.textContent = remainingItems === 0 ? 'Finishing...' : `Est. remaining: ${minutes}m ${remSeconds}s`;
        }
        
        // Small delay between stories
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    if (failedStories.length > 0) {
        showNotification(`Batch finished with ${failedStories.length} failures.`, 'warning');
        
        let retryBtn = document.getElementById('retryFailedBtn');
        if (!retryBtn) {
            retryBtn = document.createElement('button');
            retryBtn.id = 'retryFailedBtn';
            retryBtn.className = 'btn btn-secondary'; 
            retryBtn.style.cssText = 'width: 100%; margin-top: 1rem; background: #ef4444; color: white; border: none;';
            
            // Insert after start button
            const startBtn = document.querySelector('button[onclick="startBatchGeneration()"]');
            if (startBtn && startBtn.parentNode) {
                startBtn.parentNode.insertBefore(retryBtn, startBtn.nextSibling);
            }
        }
        
        retryBtn.innerHTML = `<i class="fas fa-redo"></i> Retry ${failedStories.length} Failed Stories`;
        retryBtn.style.display = 'block';
        retryBtn.onclick = () => {
            retryBtn.style.display = 'none';
            const selectFailedBtn = document.getElementById('selectFailedBtn');
            if (selectFailedBtn) selectFailedBtn.style.display = 'none';
            startBatchGeneration(failedStories);
        };
        
        let selectFailedBtn = document.getElementById('selectFailedBtn');
        if (!selectFailedBtn) {
            selectFailedBtn = document.createElement('button');
            selectFailedBtn.id = 'selectFailedBtn';
            selectFailedBtn.className = 'btn btn-secondary';
            selectFailedBtn.style.cssText = 'width: 100%; margin-top: 0.5rem; background: #475569; color: white; border: none;';
            
            if (retryBtn.parentNode) {
                retryBtn.parentNode.insertBefore(selectFailedBtn, retryBtn.nextSibling);
            }
        }
        
        selectFailedBtn.innerHTML = `<i class="fas fa-check-square"></i> Select ${failedStories.length} Failed Stories`;
        selectFailedBtn.style.display = 'block';
        selectFailedBtn.onclick = () => {
            document.querySelectorAll('.story-checkbox').forEach(cb => cb.checked = false);
            failedStories.forEach(id => {
                const cb = document.querySelector(`.story-checkbox[value="${id}"]`);
                if (cb) cb.checked = true;
            });
            const master = document.getElementById('selectAllCheckbox');
            if(master) master.checked = false;
            showNotification('Failed stories selected.');
        };
    } else {
        showNotification(`Batch complete! Generated ${completed} videos.`);
        const retryBtn = document.getElementById('retryFailedBtn');
        if (retryBtn) retryBtn.style.display = 'none';
        const selectFailedBtn = document.getElementById('selectFailedBtn');
        if (selectFailedBtn) selectFailedBtn.style.display = 'none';
    }

    if (batchProgressBar) setTimeout(() => {
        batchProgressBar.style.display = 'none';
        if (pauseBtn) pauseBtn.style.display = 'none';
    }, 2000);
    
    // Ensure generation progress is hidden
    const genProgress = document.getElementById('generationProgress');
    if (genProgress) genProgress.style.display = 'none';
}

// ==================== HELPER FUNCTIONS ====================
function showSection(sectionId) {
    // Hide all sections
    document.querySelectorAll('.section').forEach(section => {
        section.style.display = 'none';
    });
    
    // Show selected section
    const section = document.getElementById(`${sectionId}-section`);
    if (section) {
        section.style.display = 'block';
    }
    
    hideBurgerMenu();
}

function showNotification(message, type = 'info') {
    // Remove existing notification
    const existing = document.getElementById('quickNotification');
    if (existing) existing.remove();
    
    const colors = {
        info: '#3b82f6',
        success: '#10b981',
        error: '#ef4444',
        warning: '#f59e0b'
    };
    
    const notification = document.createElement('div');
    notification.id = 'quickNotification';
    notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 12px 20px;
        background: ${colors[type] || colors.info};
        color: white;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        z-index: 10001;
        animation: slideIn 0.3s ease;
        font-weight: 500;
        max-width: 300px;
        word-wrap: break-word;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 3 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.animation = 'slideOut 0.3s ease forwards';
            setTimeout(() => notification.remove(), 300);
        }
    }, 3000);
}

// Menu action functions
function showAudioLibrary() {
    showNotification('Audio Library - Click Settings → Audio Settings', 'info');
    toggleSettings();
}

function showMediaLibrary() {
    showNotification('Media Library - Coming soon!', 'info');
}

function showAnalytics() {
    showNotification('Analytics Dashboard - Coming soon!', 'info');
}

function showHelp() {
    showNotification('Help & Support - Coming soon!', 'info');
}

function toggleSettings() {
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsOverlay = document.getElementById('settingsOverlay');
    
    if (settingsPanel && settingsOverlay) {
        settingsPanel.classList.toggle('active');
        settingsOverlay.classList.toggle('active');
        hideBurgerMenu();
    } else {
        showNotification('Settings panel not found', 'error');
    }
}

function downloadVideo(url, filename) {
    if (!url) {
        const videoPlayer = document.getElementById('videoPlayer');
        if (videoPlayer && videoPlayer.src) url = videoPlayer.src;
        else return;
    }
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || `${currentFormat}_${Date.now()}.webm`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    showNotification('Video downloaded!', 'success');
}

function downloadMetadata(data, filename) {
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

// Helper function to simulate object-fit: cover for canvas images
function drawImageProp(ctx, img, x, y, w, h, offsetX, offsetY) {
    if (arguments.length === 2) {
        x = y = 0;
        w = ctx.canvas.width;
        h = ctx.canvas.height;
    }

    offsetX = typeof offsetX === "number" ? offsetX : 0.5;
    offsetY = typeof offsetY === "number" ? offsetY : 0.5;

    if (offsetX < 0) offsetX = 0;
    if (offsetX > 1) offsetX = 1;
    if (offsetY < 0) offsetY = 0;
    if (offsetY > 1) offsetY = 1;

    var iw = img.width,
        ih = img.height,
        r = Math.min(w / iw, h / ih),
        nw = iw * r,
        nh = ih * r,
        cx, cy, cw, ch, ar = 1;

    if (nw < w) ar = w / nw;                             
    if (Math.abs(ar - 1) < 1e-14 && nh < h) ar = h / nh;
    nw *= ar;
    nh *= ar;

    cw = iw / (nw / w);
    ch = ih / (nh / h);

    cx = (iw - cw) * offsetX;
    cy = (ih - ch) * offsetY;

    if (cx < 0) cx = 0; if (cy < 0) cy = 0;
    if (cw > iw) cw = iw; if (ch > ih) ch = ih;

    ctx.drawImage(img, cx, cy, cw, ch, x, y, w, h);
}

// Advanced HTML Text Renderer with Auto-Fit
function drawHtmlText(ctx, text, width, height, maxFontSize, progress = 1) {
    // Safety check for empty text
    if (!text) {
        console.warn('drawHtmlText received empty text');
        return;
    }

    const padding = width * 0.1;
    const maxWidth = width - (padding * 2);
    const maxHeight = height * 0.65; // Leave room for footer
    
    // 1. Parse HTML tags (simple parser for <br>, <b>, <span>)
    // Aggressive HTML Decode and Strip
    const decodeHTML = (str) => str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#039;/g, "'").replace(/&nbsp;/g, ' ');
    // Decode twice to handle double escaping
    let decoded = decodeHTML(decodeHTML(text));
    // Replace <br> with newline
    let withNewlines = decoded.replace(/<br\s*\/?>/gi, '\n');
    // Strip all other tags
    let cleanText = withNewlines.replace(/<\/?[^>]+(>|$)/g, "");
    
    // Function to calculate layout for a given font size
    function calculateLayout(fontSize) {
        ctx.font = `bold ${fontSize}px Arial`;
        const lineHeight = fontSize * 1.4;
        const lines = [];
        
        const paragraphs = cleanText.split('\n');
        
        paragraphs.forEach(para => {
            if (!para.trim()) {
                lines.push({ segments: [], width: 0 }); // Empty line
                return;
            }
            
            const words = para.split(' ');
            let currentLine = [];
            let currentLineWidth = 0;
            
            words.forEach(word => {
                // Check for tags in word
                let isBold = word.includes('<b>') || word.includes('</b>');
                let colorMatch = word.match(/style=['"]color:\s*([^'"]+)['"]/);
                let color = colorMatch ? colorMatch[1] : null;
                
                // Strip tags for measurement
                let cleanWord = word.replace(/<[^>]*>/g, '');
                
                // Measure
                ctx.font = isBold ? `900 ${fontSize}px Arial` : `bold ${fontSize}px Arial`;
                let wordWidth = ctx.measureText(cleanWord + ' ').width;
                
                if (currentLineWidth + wordWidth < maxWidth) {
                    currentLine.push({ text: cleanWord, bold: isBold, color: color });
                    currentLineWidth += wordWidth;
                } else {
                    lines.push({ segments: currentLine, width: currentLineWidth });
                    currentLine = [{ text: cleanWord, bold: isBold, color: color }];
                    currentLineWidth = wordWidth;
                }
            });
            lines.push({ segments: currentLine, width: currentLineWidth });
        });
        
        return { lines, totalHeight: lines.length * lineHeight, lineHeight };
    }
    
    // 2. Auto-fit logic: Reduce font size until it fits
    let fontSize = maxFontSize;
    let layout = calculateLayout(fontSize);
    
    while (layout.totalHeight > maxHeight && fontSize > 10) {
        fontSize -= 2;
        layout = calculateLayout(fontSize);
    }
    
    // 3. Render
    const startY = (height - layout.totalHeight) / 2 - (height * 0.05); // Shift up slightly to avoid watermark
    
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0, 0, 0, 1.0)';
    ctx.shadowBlur = 20; // Increased glow
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.globalAlpha = progress;

    layout.lines.forEach((line, lineIndex) => {
        const y = startY + (lineIndex * layout.lineHeight) + (layout.lineHeight / 2);
        
        // Calculate total width of line to center it
        let lineWidth = 0;
        line.segments.forEach(seg => {
            ctx.font = (seg.text.includes('<b>') || text.includes('<b>')) ? `900 ${fontSize}px Arial` : `bold ${fontSize}px Arial`;
            // Simple bold check: if the original segment had tags. 
            // Note: The simple parser above is word-based. For better results, we assume whole words are bold.
            // Re-checking bold status from original word context is tricky in this simple loop.
            // Let's rely on the 'bold' flag stored in segment.
            if (seg.bold) ctx.font = `900 ${fontSize}px Arial`;
            else ctx.font = `bold ${fontSize}px Arial`;
            
            lineWidth += ctx.measureText(seg.text + ' ').width;
        });
        
        let currentX = (width - lineWidth) / 2;
        
        line.segments.forEach(seg => {
            ctx.font = seg.bold ? `900 ${fontSize}px Arial` : `bold ${fontSize}px Arial`;
            ctx.fillStyle = seg.color || '#ffffff';
            
            ctx.fillText(seg.text, currentX + (ctx.measureText(seg.text).width / 2), y);
            currentX += ctx.measureText(seg.text + ' ').width;
        });
    });
    
    // Reset
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
}

// Canvas functions
function drawStoryFrame(ctx, storyText, time, width, height) {
    const fontSize = parseInt(document.getElementById('textSize')?.value || 48);
    
    // Fast fade-in (0.5s) to ensure text is readable quickly
    // Default to visible for static preview
    let progress = 1;
    if ((typeof isPreviewPlaying !== 'undefined' && isPreviewPlaying) || (typeof activeGenerations !== 'undefined' && activeGenerations > 0)) {
        progress = Math.min(time / 0.5, 1);
    }
    
    // Draw semi-transparent overlay for readability
   if (backgroundImage && backgroundImage.complete) {
        const bgDim = document.getElementById('bgDim') ? parseInt(document.getElementById('bgDim').value) / 100 : 0.60;
        ctx.fillStyle = `rgba(0, 0, 0, ${bgDim})`;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#ffffff'; // Reset text color
    }

    // Use the new HTML renderer
    drawHtmlText(ctx, storyText, width, height, fontSize, progress);
}

function drawWatermarkFrame(ctx, width, height, img = watermarkImage) {
    if (!img) return;
    
    const opacity = parseInt(document.getElementById('watermarkOpacity')?.value || 50) / 100;
    const size = parseInt(document.getElementById('watermarkSize')?.value || 20) / 100;
    
    // Use img dimensions if available, fallback to watermarkImage or 1:1
    const w = img.naturalWidth || img.width || watermarkImage?.width || 100;
    const h = img.naturalHeight || img.height || watermarkImage?.height || 100;
    const ratio = h / w;
    
    const watermarkWidth = width * size;
    const watermarkHeight = ratio * watermarkWidth;
    
    const x = width - watermarkWidth - 30;
    const y = height - watermarkHeight - 30;
    
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.drawImage(img, x, y, watermarkWidth, watermarkHeight);
    
    // Add Credit Text: Rajesh Motwani (mots.ai)
    ctx.globalAlpha = 0.9; // Ensure text is visible
    const fontSize = Math.max(10, watermarkWidth * 0.07); 
    ctx.font = `500 ${fontSize}px sans-serif`;
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 3;
    const creditText = document.getElementById('creditText')?.value || "Its Mots | AIPC Thane";
    ctx.fillText(creditText, x + watermarkWidth, y + watermarkHeight + 4);
    
    ctx.restore();
}

function drawSafeZones(ctx, width, height) {
    const format = currentFormat;
    
    ctx.save();
    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)'; // Red tint for unsafe areas
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.lineWidth = 2;
    
    // Vertical Video (9:16) - TikTok, Shorts, Reels
    if (format === 'tiktok' || format === 'shorts' || (format === 'instagram' && height > width)) {
        // Right side buttons (Like, Comment, Share)
        ctx.fillRect(width * 0.82, height * 0.35, width * 0.18, height * 0.4);
        
        // Bottom caption/description area
        ctx.fillRect(0, height * 0.85, width, height * 0.15);
        
        // Top header/search area
        ctx.fillRect(0, 0, width, height * 0.08);
        
        // Draw safe area border
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(width * 0.05, height * 0.08, width * 0.77, height * 0.77);
        
    } else if (format === 'youtube') {
        // Landscape 16:9
        // Bottom controls / captions
        ctx.fillRect(0, height * 0.85, width, height * 0.15);
        
        // Title safe area (approx 80%)
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(width * 0.1, height * 0.1, width * 0.8, height * 0.8);
    } else {
        // Square or others - General margins
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(width * 0.05, height * 0.05, width * 0.9, height * 0.9);
    }
    
    ctx.restore();
}

// Render stories lists
function renderStoriesList() {
    const storiesList = document.getElementById('storiesList');
    const importedStoriesList = document.getElementById('importedStoriesList');
    
    if (storiesList) {
        storiesList.innerHTML = '';
        stories.forEach(story => {
            const storyItem = document.createElement('div');
            storyItem.className = 'story-item';
            storyItem.onclick = () => {
                currentStory = story.story;
                currentStoryData = story; // Store full object
                const storyTextArea = document.getElementById('storyText');
                if (storyTextArea) storyTextArea.value = story.story;
                showSection('creator');
                
                // Auto-load background image
                const imgPath = `assets/posters/2026-bmc/page_${story.slideNumber}.jpg`;
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    backgroundImage = img;
                    showNotification(`Loaded background for Slide ${story.slideNumber}`, 'success');
                    drawPreview();
                };
                img.onerror = () => {
                    console.log(`No image found for slide ${story.slideNumber}`);
                };
                img.src = imgPath;

                showNotification(`Loaded: ${story.lineItem}`, 'success');
                drawPreview();
            };
            
            storyItem.innerHTML = `
                <div class="story-title">${story.slideTitleEN} - ${story.lineItem}</div>
                <div class="story-meta">
                    <span>Slide ${story.slideNumber}</span>
                    <span class="status-badge status-${story.status}">${story.status}</span>
                </div>
            `;
            
            storiesList.appendChild(storyItem);
        });
    }
    
    if (importedStoriesList) {
        importedStoriesList.innerHTML = '';
        stories.forEach(story => {
            const storyItem = document.createElement('div');
            storyItem.className = 'story-item';
            storyItem.onclick = () => {
                currentStory = story.story;
                currentStoryData = story; // Store full object
                const storyTextArea = document.getElementById('storyText');
                if (storyTextArea) storyTextArea.value = story.story;
                showSection('creator');
                
                // Auto-load background image
                const imgPath = `assets/posters/2026-bmc/page_${story.slideNumber}.jpg`;
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    backgroundImage = img;
                    // Trigger a redraw of preview if possible, or just let the loop handle it
                    showNotification(`Loaded background for Slide ${story.slideNumber}`, 'success');
                    drawPreview();
                };
                img.onerror = () => {
                    console.log(`No image found for slide ${story.slideNumber}`);
                };
                img.src = imgPath;
                
                showNotification(`Loaded: ${story.lineItem}`, 'success');
                drawPreview();
            };
            
            storyItem.innerHTML = `
                <div class="story-title">${story.slideTitleEN} - ${story.lineItem}</div>
                <div class="story-meta">
                    <span>Slide ${story.slideNumber}</span>
                    <span class="status-badge status-${story.status}">${story.status}</span>
                </div>
            `;
            
            importedStoriesList.appendChild(storyItem);
        });
    }
}

function renderBatchStoriesList() {
    const batchStoriesList = document.getElementById('batchStoriesList');
    const batchImportBanner = document.querySelector('#batch-section .json-import');
    const batchActions = document.getElementById('batchActions');
    const batchLibraryControls = document.getElementById('batchLibraryControls');

    if (!batchStoriesList) return;
    
    batchStoriesList.innerHTML = '';

    // Toggle Import Banner based on content
    if (stories.length > 0) {
        if (batchImportBanner) batchImportBanner.style.display = 'none';
        if (batchActions) batchActions.style.display = 'flex';
        
        // Inject Quick Library Dropdown into Batch Actions if not present
        if (batchLibraryControls && batchLibraryControls.innerHTML === '') {
            const select = document.createElement('select');
            select.className = 'form-control';
            select.style.padding = '5px';
            select.style.borderRadius = '4px';
            select.innerHTML = `<option value="">📂 Quick Load from Library...</option>`;
            
            libraryFiles.forEach(file => {
                select.innerHTML += `<option value="${file.path}">${file.name}</option>`;
            });
            
            select.onchange = (e) => {
                if(e.target.value) window.SmartVideoGenerator.loadJSONFromPath(e.target.value);
            };
            batchLibraryControls.appendChild(select);
        }
        
        // Add Select All Header
        const headerItem = document.createElement('div');
        headerItem.className = 'story-item';
        headerItem.style.cssText = 'background: #f8fafc; border-bottom: 2px solid #e2e8f0; position: sticky; top: 0; z-index: 10; font-weight: 600;';
        
        headerItem.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <input type="checkbox" id="selectAllCheckbox" style="margin-top: 0; width: 16px; height: 16px; cursor: pointer;" checked>
                <label for="selectAllCheckbox" style="cursor: pointer; user-select: none; flex: 1;">Select All (${stories.length} Stories)</label>
            </div>
        `;
        headerItem.querySelector('#selectAllCheckbox').addEventListener('change', function() {
            document.querySelectorAll('.story-checkbox').forEach(cb => cb.checked = this.checked);
        });
        batchStoriesList.appendChild(headerItem);
    } else {
        if (batchImportBanner) batchImportBanner.style.display = 'block';
        if (batchActions) batchActions.style.display = 'none';
    }

    stories.forEach(story => {
        const batchItem = document.createElement('div');
        batchItem.className = 'story-item';
        batchItem.setAttribute('data-status', story.status);
        
        batchItem.innerHTML = `
            <div style="display: flex; align-items: flex-start; gap: 1rem;">
                <input type="checkbox" class="story-checkbox" value="${story.id}" 
                       style="margin-top: 0.25rem;" ${story.status === 'ready' ? 'checked' : ''}>
                <div style="flex: 1;">
                    <div class="story-title">${story.slideTitleEN} - ${story.lineItem}</div>
                    <div class="story-meta">
                        <span>Slide ${story.slideNumber}</span>
                        <span class="status-badge status-${story.status}">${story.status}</span>
                    </div>
                </div>
            </div>
        `;
        
        batchStoriesList.appendChild(batchItem);
    });
}

function setupSystemMonitor() {
    const memDisplay = document.getElementById('memoryStats');
    const memValue = document.getElementById('memValue');
    const cpuDisplay = document.getElementById('cpuStats');
    const cpuValue = document.getElementById('cpuValue');
    
    if (performance && performance.memory) {
        memDisplay.style.display = 'block';
        
        setInterval(() => {
            const memory = performance.memory;
            const usedMB = Math.round(memory.usedJSHeapSize / (1024 * 1024));
            const limitMB = Math.round(memory.jsHeapSizeLimit / (1024 * 1024));
            const usage = Math.round((usedMB / limitMB) * 100);
            
            memValue.textContent = `${usedMB} MB`;
            
            if (usage > 90) memDisplay.style.color = '#ef4444'; // Red
            else if (usage > 70) memDisplay.style.color = '#f59e0b'; // Orange
            else memDisplay.style.color = '#94a3b8'; // Default
            
            // Auto-pause logic
            if (document.getElementById('autoPauseMemory')?.checked && usage > 90) {
                const batchProgress = document.getElementById('batchProgress');
                if (!isBatchPaused && batchProgress && batchProgress.style.display === 'block') {
                    toggleBatchPause();
                    showNotification('⚠️ High Memory! Batch paused automatically.', 'warning');
                }
            }
        }, 2000);
    }
    
    // CPU/Load Monitor (Main Thread Lag Estimator)
    if (cpuDisplay) {
        cpuDisplay.style.display = 'block';
        let lastLoop = Date.now();
        
        setInterval(() => {
            const now = Date.now();
            const delta = now - lastLoop;
            lastLoop = now;
            
            // Expected 2000ms. Calculate lag.
            const expected = 2000;
            const lag = Math.max(0, delta - expected);
            const load = Math.min(100, Math.round((lag / 1000) * 100)); // 1s lag = 100% load
            
            cpuValue.textContent = `${load}% Load`;
            
            if (load > 50) cpuDisplay.style.color = '#ef4444';
            else if (load > 20) cpuDisplay.style.color = '#f59e0b';
            else cpuDisplay.style.color = '#94a3b8';
        }, 2000);
    }
}

// ==================== INITIALIZATION ====================
function initAll() {
    console.log('Initializing Smart Video Generator...');
    
    // Add animation styles
    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        /* Make burger menu responsive */
        @media (max-width: 768px) {
            #burgerMenu {
                width: 85vw !important;
                max-width: 300px !important;
                left: 10px !important;
                right: 10px !important;
                margin: 0 auto;
            }
        }
    `;
    document.head.appendChild(style);
    
    // Setup burger menu
    createBurgerMenu();
    
    // Setup audio
    setupAudioContext();
    
    // Setup JSON import
    setupJSONImport();
    
    // Setup progress bars
    setupProgressBars();
    
    // Setup system monitor
    setupSystemMonitor();
    
    // Setup Formats & Canvas
    setupFormats();
    updateCanvasSize();
    
    // Auto-load default watermark
    const defaultWatermark = new Image();
    defaultWatermark.src = 'assets/watermark/default.jpg';
    defaultWatermark.onload = () => { 
        watermarkImage = defaultWatermark; 
    };
    
    // Auto-load default audio
    const defaultAudio = new Audio('assets/audio/default.mp3');
    defaultAudio.oncanplaythrough = () => {
        audioFile = defaultAudio;
        console.log('Default audio loaded');
    };
    defaultAudio.onerror = () => {
        console.log('Default audio not found at assets/audio/default.mp3');
    };
    
    // Load sample stories
    loadSampleJSON();
    loadSettings(); // Load persisted settings
    
    // Setup event listeners
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            hideBurgerMenu();
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel?.classList.contains('active')) {
                toggleSettings();
            }
        }
    });
    
    // Connect Batch Upload to the main handler (moved here for safety)
    const batchUpload = document.getElementById('batchJsonUpload');
    if (batchUpload) {
        batchUpload.addEventListener('change', handleJSONFileUpload);
    }
    
    // Window resize handler
    window.addEventListener('resize', updateCanvasSize);
    
    // Story text input handler
    const storyText = document.getElementById('storyText');
    if (storyText) {
        storyText.addEventListener('input', (e) => {
            currentStory = e.target.value;
            drawPreview();
        });
    }
    
    console.log('Smart Video Generator initialized successfully!');
    showNotification('System ready! Click the burger menu (☰) to start.', 'success');
}

// ==================== SETTINGS PERSISTENCE ====================
function saveSettings() {
    const settings = {
        watermarkOpacity: document.getElementById('watermarkOpacity')?.value,
        watermarkSize: document.getElementById('watermarkSize')?.value,
        textSize: document.getElementById('textSize')?.value,
        animationSpeed: document.getElementById('animationSpeed')?.value,
        bgDim: document.getElementById('bgDim')?.value,
        audioVolume: document.getElementById('audioVolume')?.value,
        autoDownload: document.getElementById('autoDownload')?.checked,
        addWatermark: document.getElementById('addWatermark')?.checked,
        includeAudio: document.getElementById('includeAudio')?.checked,
        showSafeZones: document.getElementById('showSafeZones')?.checked,
        enableKenBurns: document.getElementById('enableKenBurns')?.checked,
        creditText: document.getElementById('creditText')?.value,
        generateMetadata: document.getElementById('generateMetadata')?.checked,
        performanceMode: document.getElementById('performanceMode')?.checked,
        autoPauseMemory: document.getElementById('autoPauseMemory')?.checked,
        muteDuringGeneration: document.getElementById('muteDuringGeneration')?.checked,
        selectedFormats: selectedFormats,
        currentFormat: currentFormat
    };
    localStorage.setItem('videoGeneratorSettings', JSON.stringify(settings));
}

function loadSettings() {
    const saved = localStorage.getItem('videoGeneratorSettings');
    if (!saved) return;
    
    try {
        const settings = JSON.parse(saved);
        
        if (settings.watermarkOpacity) { document.getElementById('watermarkOpacity').value = settings.watermarkOpacity; updateWatermarkOpacity(settings.watermarkOpacity); }
        if (settings.watermarkSize) { document.getElementById('watermarkSize').value = settings.watermarkSize; updateWatermarkSize(settings.watermarkSize); }
        if (settings.textSize) { document.getElementById('textSize').value = settings.textSize; updateTextSize(settings.textSize); }
        if (settings.animationSpeed) { document.getElementById('animationSpeed').value = settings.animationSpeed; updateAnimationSpeed(settings.animationSpeed); }
        if (settings.bgDim) { document.getElementById('bgDim').value = settings.bgDim; updateBgDim(settings.bgDim); }
        if (settings.audioVolume) { document.getElementById('audioVolume').value = settings.audioVolume; updateAudioVolume(settings.audioVolume); }
        if (settings.creditText) { document.getElementById('creditText').value = settings.creditText; }
        
        setCheckbox('autoDownload', settings.autoDownload);
        setCheckbox('addWatermark', settings.addWatermark);
        setCheckbox('includeAudio', settings.includeAudio);
        setCheckbox('showSafeZones', settings.showSafeZones);
        setCheckbox('enableKenBurns', settings.enableKenBurns);
        setCheckbox('generateMetadata', settings.generateMetadata);
        setCheckbox('performanceMode', settings.performanceMode);
        setCheckbox('autoPauseMemory', settings.autoPauseMemory);
        setCheckbox('muteDuringGeneration', settings.muteDuringGeneration);
        
        if (settings.selectedFormats) selectedFormats = settings.selectedFormats;
        if (settings.currentFormat) currentFormat = settings.currentFormat;
        
        setupFormats();
        updateCanvasSize();
        drawPreview();
    } catch (e) {
        console.error('Error loading settings', e);
    }
}

function setCheckbox(id, value) {
    const el = document.getElementById(id);
    if (el && value !== undefined) el.checked = value;
}

function resetSettings() {
    if(confirm('Reset all settings to default?')) {
        localStorage.removeItem('videoGeneratorSettings');
        location.reload();
    }
}

// ==================== GLOBAL API ====================
window.SmartVideoGenerator = {
    init: initAll,
    generateVideo: generateVideo,
    startBatchGeneration: startBatchGeneration,
    uploadAudio: uploadAudio,
    toggleSettings: toggleSettings,
    showSection: showSection,
    toggleBurgerMenu: toggleBurgerMenu,
    loadJSONFromPath: loadJSONFromPath
};

// ==================== AUTO-INITIALIZE ====================
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll);
} else {
    initAll();
}

// Also initialize on window load
// window.addEventListener('load', initAll); // Removed to prevent double initialization
window.generateVideo = generateVideo;
window.startBatchGeneration = startBatchGeneration;
window.downloadVideo = downloadVideo;
window.resetStories = resetStories;
window.filterBatchStories = filterBatchStories;
window.toggleBatchPause = toggleBatchPause;
window.resetSettings = resetSettings;
window.saveSettings = saveSettings;
        }
    </script>
</body>
</html>